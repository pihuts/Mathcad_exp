---
phase: 04-library-persistence
plan: 02
type: execute
wave: 1
depends_on:
  - 04-01
files_modified:
  - src/server/routes.py
  - src/server/schemas.py
autonomous: true

must_haves:
  truths:
    - "User can list all saved library configs via API"
    - "User can load a specific saved config by name"
    - "API returns configs with resolved absolute paths"
    - "Configs validate on load using Pydantic"
  artifacts:
    - path: "src/server/routes.py"
      provides: "GET /library/list and POST /library/load endpoints"
      exports: ["GET /library/list", "POST /library/load"]
    - path: "src/server/schemas.py"
      provides: "ListLibraryConfigsResponse and LoadLibraryConfigRequest schemas"
      contains: "class ListLibraryConfigsResponse"
  key_links:
    - from: "src/server/routes.py"
      to: "src/engine/protocol.py"
      via: "BatchConfig.model_validate() for loading JSON configs"
      pattern: "BatchConfig\.model_validate\("
    - from: "src/server/routes.py"
      to: "file system"
      via: "Path.glob('*.json') for discovering configs"
      pattern: "\.glob\('\*\.json'\)"
---

<objective>
Create backend API endpoints for listing and loading saved batch configurations from the library.

Purpose: Enable engineers to browse existing saved configurations and reload them into the application for reuse.
Output: Working GET /library/list and POST /library/load endpoints that return validated BatchConfig objects.
</objective>

<execution_context>
@C:\Users\peter\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\peter\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-library-persistence/04-01-PLAN.md
@src/engine/protocol.py
@src/server/routes.py
@src/server/schemas.py

# Research-backed decisions
@.planning/phases/04-library-persistence/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Add library list endpoint to routes.py</name>
  <files>src/server/routes.py</files>
  <action>
    Add to src/server/routes.py after /library/save endpoint:

    ```python
    @router.get("/library/list")
    async def list_library_configs(file_path: str):
        """
        List all saved library configurations for a given Mathcad file.
        Returns metadata (name, path, created_at) for each config.
        """
        from pathlib import Path
        import json

        try:
            mcdx_path = Path(file_path)
            if not mcdx_path.exists():
                raise HTTPException(status_code=400, detail=f"Mathcad file not found: {file_path}")

            config_dir = mcdx_path.parent / f"{mcdx_path.stem}_configs"

            if not config_dir.exists():
                return {"configs": []}

            configs = []
            for config_file in config_dir.glob("*.json"):
                try:
                    config_data = json.loads(config_file.read_text(encoding='utf-8'))
                    configs.append({
                        "name": config_data.get("name", config_file.stem),
                        "path": str(config_file),
                        "created_at": config_data.get("created_at", "unknown"),
                        "version": config_data.get("version", "1.0")
                    })
                except Exception:
                    # Skip corrupted config files
                    continue

            return {"configs": configs}
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))
    ```

    This endpoint:
    - Takes file_path query parameter (the .mcdx file)
    - Looks for {filename}_configs/ directory
    - Returns list of configs with metadata (no full input data)
    - Skips corrupted JSON files (fails gracefully)
  </action>
  <verify>Python passes: `python -c "from src.server.routes import router; print([r.path for r in router.routes if r.path == '/library/list'])"`</verify>
  <done>GET /library/list endpoint exists, returns config metadata list</done>
</task>

<task type="auto">
  <name>Add library load endpoint to routes.py</name>
  <files>src/server/routes.py</files>
  <action>
    Add to src/server/routes.py after /library/list endpoint:

    ```python
    @router.post("/library/load")
    async def load_library_config(req: Dict[str, Any]):
        """
        Load a saved library configuration by file path.
        Returns BatchConfig with absolute paths resolved.
        """
        from pathlib import Path
        from src.engine.protocol import BatchConfig
        import json

        try:
            config_path_str = req.get("config_path")
            if not config_path_str:
                raise HTTPException(status_code=400, detail="Missing config_path")

            config_path = Path(config_path_str)
            if not config_path.exists():
                raise HTTPException(status_code=404, detail=f"Config file not found: {config_path_str}")

            # Read and validate using Pydantic
            config_json = config_path.read_text(encoding='utf-8')
            config_dict = json.loads(config_json)

            # Resolve relative paths to absolute
            mcdx_path = config_path.parent.parent / config_dict['file_path']
            config_dict['file_path'] = str(mcdx_path.resolve())

            if config_dict.get('output_dir'):
                output_abs = config_path.parent.parent / config_dict['output_dir']
                config_dict['output_dir'] = str(output_abs.resolve())

            # Validate with Pydantic
            config = BatchConfig.model_validate(config_dict)

            return config.model_dump(mode='json')
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))
    ```

    This endpoint:
    - Takes config_path in request body
    - Reads JSON and validates with Pydantic
    - Resolves relative paths to absolute (file_path, output_dir)
    - Returns full BatchConfig for loading into UI
  </action>
  <verify>Python passes: `python -c "from src.server.routes import router; print([r.path for r in router.routes if r.path == '/library/load'])"`</verify>
  <done>POST /library/load endpoint exists, validates config, resolves paths to absolute</done>
</task>

<task type="auto">
  <name>Add library list/load schemas to schemas.py</name>
  <files>src/server/schemas.py</files>
  <action>
    Add to src/server/schemas.py after SaveLibraryConfigResponse:

    ```python
    class LibraryConfigMetadata(BaseModel):
        name: str
        path: str
        created_at: str
        version: str = "1.0"

    class ListLibraryConfigsResponse(BaseModel):
        configs: List[LibraryConfigMetadata]

    class LoadLibraryConfigRequest(BaseModel):
        config_path: str
    ```

    These schemas provide type safety and documentation for the library endpoints.
  </action>
  <verify>Python passes: `python -c "from src.server.schemas import ListLibraryConfigsResponse, LoadLibraryConfigRequest; print('Schemas imported successfully')"`</verify>
  <done>ListLibraryConfigsResponse and LoadLibraryConfigRequest schemas exist</done>
</task>

</tasks>

<verification>
## Backend Library API Verification

1. **List Endpoint Test**: Create test config and list
   ```bash
   # Assumes plan 01 complete and test config exists
   curl "http://localhost:8000/api/v1/library/list?file_path=/path/to/test.mcdx"
   ```

2. **Load Endpoint Test**: Load specific config
   ```bash
   curl -X POST http://localhost:8000/api/v1/library/load \
     -H "Content-Type: application/json" \
     -d '{"config_path": "/path/to/test_configs/Test Config.json"}'
   ```

3. **Path Resolution Verification**:
   - Confirm loaded config has absolute file_path
   - Confirm output_dir resolved if present
   - Confirm Pydantic validation rejects malformed configs
</verification>

<success_criteria>
1. GET /library/list returns array of config metadata for given .mcdx file
2. POST /library/load returns full BatchConfig with absolute paths
3. Empty configs array returned when no configs directory exists
4. Corrupted config files skipped (not crash) in list endpoint
5. Pydantic validates loaded configs (returns 500 on invalid JSON)
6. Relative paths resolved correctly on load
</success_criteria>

<output>
After completion, create `.planning/phases/04-library-persistence/04-02-SUMMARY.md` with:
- List and load endpoint implementations
- Path resolution strategy (relative -> absolute)
- Error handling for missing/corrupted configs
- Integration with BatchConfig from plan 01
</output>
