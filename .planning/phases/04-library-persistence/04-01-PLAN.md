---
phase: 04-library-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/protocol.py
  - src/server/routes.py
  - src/server/schemas.py
autonomous: true

must_haves:
  truths:
    - "User can save batch configuration as named template via API"
    - "Saved configuration persists as JSON file on disk"
    - "API endpoint validates configuration before saving"
    - "Library configs use relative paths for portability"
  artifacts:
    - path: "src/engine/protocol.py"
      provides: "BatchConfig Pydantic model for type-safe config serialization"
      contains: "class BatchConfig"
    - path: "src/server/routes.py"
      provides: "POST /library/save endpoint for saving configurations"
      exports: ["POST /library/save"]
    - path: "src/server/schemas.py"
      provides: "SaveLibraryConfigRequest and SaveLibraryConfigResponse schemas"
      contains: "class SaveLibraryConfigRequest"
  key_links:
    - from: "src/server/routes.py"
      to: "src/engine/protocol.py"
      via: "from src.engine.protocol import BatchConfig"
      pattern: "from src.engine.protocol import BatchConfig"
    - from: "src/server/routes.py"
      to: "file system"
      via: "Path.write_text() for JSON persistence"
      pattern: "\.write_text\(|\.model_dump\(mode='json'\)"
---

<objective>
Create backend API and data models for saving batch configurations as reusable library templates.

Purpose: Enable engineers to save common input configurations (e.g., "Bolt Diameters", "Load Cases") and reload them later, eliminating repetitive data entry.
Output: Working POST /library/save endpoint that persists validated BatchConfig objects as JSON files.
</objective>

<execution_context>
@C:\Users\peter\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\peter\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-batch-processing-system/02-01-PLAN.md
@src/engine/protocol.py
@src/server/routes.py
@src/server/schemas.py

# Research-backed decisions
@.planning/phases/04-library-persistence/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create BatchConfig Pydantic model in protocol.py</name>
  <files>src/engine/protocol.py</files>
  <action>
    Add to src/engine/protocol.py after WorkflowConfig class (around line 62):

    ```python
    class BatchConfig(BaseModel):
        """Complete batch configuration for library persistence"""
        name: str = Field(..., min_length=1, max_length=100)
        file_path: str  # Path to .mcdx file (will be stored as relative)
        inputs: List[InputConfig]  # Reuse existing InputConfig dataclass
        export_pdf: bool = True
        export_mcdx: bool = False
        output_dir: Optional[str] = None
        created_at: str = Field(default_factory=lambda: datetime.now().isoformat())
        version: str = "1.0"

        # For relative path resolution
        base_path: Optional[str] = None  # Resolved at load time
    ```

    Import requirements:
    - Add `from datetime import datetime` to imports at top
    - Ensure `Field` is imported from pydantic

    This model reuses existing InputConfig dataclass and follows the same pattern as WorkflowConfig (Pydantic BaseModel with version field).
  </action>
  <verify>Python passes: `python -c "from src.engine.protocol import BatchConfig; print(BatchConfig.model_fields.keys())"`</verify>
  <done>BatchConfig model exists with all required fields, version field, and uses InputConfig for inputs</done>
</task>

<task type="auto">
  <name>Add library save endpoint to routes.py</name>
  <files>src/server/routes.py</files>
  <action>
    Add to src/server/routes.py after the /files/browse endpoint (around line 200):

    ```python
    # Library Endpoints

    @router.post("/library/save")
    async def save_library_config(req: Dict[str, Any]):
        """
        Save a batch configuration as a named library template.
        Configs are stored as JSON files in {mcdx_file_parent}/{mcdx_filename}_configs/
        """
        from pathlib import Path
        from src.engine.protocol import BatchConfig
        import json

        try:
            # Parse and validate request using Pydantic
            config = BatchConfig(**req)

            # Determine config directory (next to the .mcdx file)
            mcdx_path = Path(config.file_path)
            if not mcdx_path.exists():
                raise HTTPException(status_code=400, detail=f"Mathcad file not found: {config.file_path}")

            config_dir = mcdx_path.parent / f"{mcdx_path.stem}_configs"
            config_dir.mkdir(exist_ok=True)

            # Sanitize config name for filename
            safe_name = "".join(c for c in config.name if c.isalnum() or c in (' ', '-', '_')).strip()
            config_file = config_dir / f"{safe_name}.json"

            # Convert to relative paths for portability
            config_dict = config.model_dump(mode='json')
            config_dict['file_path'] = str(mcdx_path.name)  # Store just filename
            if config_dict.get('output_dir'):
                output_rel = str(Path(config_dict['output_dir']).relative_to(mcdx_path.parent))
                config_dict['output_dir'] = output_rel

            # Write JSON file
            config_file.write_text(json.dumps(config_dict, indent=2), encoding='utf-8')

            return {
                "status": "success",
                "config_path": str(config_file),
                "config_name": config.name
            }
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))
    ```

    Import requirements:
    - Add `import sys` to imports at top (for os.startfile fallback)
    - Note: Path, json, BatchConfig imported inline

    This endpoint:
    - Validates config via Pydantic (BatchConfig)
    - Creates {filename}_configs/ directory next to .mcdx file
    - Stores paths as relative (filename only, output_dir relative)
    - Returns saved config path for confirmation
  </action>
  <verify>Python passes: `python -c "from src.server.routes import router; print([r.path for r in router.routes if 'library' in r.path])"` shows "/library/save"</verify>
  <done>POST /library/save endpoint exists, validates BatchConfig, creates config directory, saves JSON with relative paths</done>
</task>

<task type="auto">
  <name>Add library request/response schemas to schemas.py</name>
  <files>src/server/schemas.py</files>
  <action>
    Add to src/server/schemas.py after BatchStatus class (around line 40):

    ```python
    class SaveLibraryConfigRequest(BaseModel):
        name: str
        file_path: str
        inputs: List[Dict[str, Any]]
        export_pdf: bool = True
        export_mcdx: bool = False
        output_dir: Optional[str] = None

    class SaveLibraryConfigResponse(BaseModel):
        status: str
        config_path: str
        config_name: str
    ```

    These schemas provide FastAPI with request/response validation and auto-documentation.
  </action>
  <verify>Python passes: `python -c "from src.server.schemas import SaveLibraryConfigRequest; print(SaveLibraryConfigRequest.model_fields.keys())"`</verify>
  <done>SaveLibraryConfigRequest and SaveLibraryConfigResponse schemas exist with correct field types</done>
</task>

</tasks>

<verification>
## Backend Implementation Verification

1. **Model Validation**: Test BatchConfig creation
   ```bash
   python -c "
   from src.engine.protocol import BatchConfig, InputConfig
   config = BatchConfig(
       name='Test Config',
       file_path='test.mcdx',
       inputs=[InputConfig(alias='test', value=1.0)],
       export_pdf=True
   )
   print('BatchConfig validation:', config.model_dump_json())
   "
   ```

2. **Endpoint Registration**: Verify route exists
   ```bash
   python -c "from src.server.main import app; print([r.path for r in app.routes if 'library' in r.path])"
   ```

3. **Save Operation Test**: Manual test via curl or frontend
   - POST to /api/v1/library/save with valid BatchConfig JSON
   - Verify {filename}_configs/ directory created
   - Verify .json file written with relative paths
</verification>

<success_criteria>
1. BatchConfig Pydantic model exists in protocol.py with all required fields
2. POST /library/save endpoint accepts and validates BatchConfig
3. Configs save as JSON files in {filename}_configs/ directories
4. File paths stored as relative (portable across machines)
5. Response returns config_path and config_name
6. No errors when importing modified modules
</success_criteria>

<output>
After completion, create `.planning/phases/04-library-persistence/04-01-SUMMARY.md` with:
- Changes made to protocol.py, routes.py, schemas.py
- BatchConfig model structure
- Save endpoint behavior and file storage pattern
- Any issues encountered and resolutions
</output>
