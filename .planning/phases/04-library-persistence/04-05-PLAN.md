---
phase: 04-library-persistence
plan: 05
type: execute
wave: 3
depends_on:
  - 04-04
files_modified:
  - frontend/src/components/LibraryModal.tsx
  - frontend/src/App.tsx
  - frontend/src/components/WorkflowBuilder.tsx
autonomous: false

must_haves:
  truths:
    - "User can save workflow configurations to library"
    - "User can load saved workflow configurations"
    - "Workflow configs include file mappings and export settings"
    - "Workflow library UI integrated into Workflow tab"
  artifacts:
    - path: "frontend/src/components/WorkflowLibraryModal.tsx"
      provides: "Modal component for workflow library operations"
      contains: "export const WorkflowLibraryModal"
    - path: "frontend/src/App.tsx"
      provides: "Workflow library button and modal integration"
      contains: "WorkflowLibraryModal"
    - path: "frontend/src/components/WorkflowBuilder.tsx"
      provides: "Load callback for workflow configs"
      contains: "onLoadWorkflow"
  key_links:
    - from: "frontend/src/components/WorkflowLibraryModal.tsx"
      to: "frontend/src/hooks/useWorkflowLibrary"
      via: "const { configs, saveConfig, loadConfig } = useWorkflowLibrary()"
      pattern: "useWorkflowLibrary\("
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/WorkflowLibraryModal.tsx"
      via: "import { WorkflowLibraryModal } from './components/WorkflowLibraryModal'"
      pattern: "import.*WorkflowLibraryModal"
---

<objective>
Extend library system to support workflow configurations (multi-file chains with mappings).

Purpose: Enable engineers to save and reuse complete workflow configurations including file chain, input mappings, and export settings.
Output: Working WorkflowLibraryModal component with workflow save/load functionality.
</objective>

<execution_context>
@C:\Users\peter\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\peter\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-library-persistence/04-01-PLAN.md
@.planning/phases/04-library-persistence/04-02-PLAN.md
@.planning/phases/04-library-persistence/04-03-PLAN.md
@.planning/phases/04-library-persistence/04-04-PLAN.md
@frontend/src/components/LibraryModal.tsx
@frontend/src/App.tsx
@frontend/src/components/WorkflowBuilder.tsx
@src/engine/protocol.py

# Research-backed decisions
@.planning/phases/04-library-persistence/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Add WorkflowConfig library support to backend</name>
  <files>src/engine/protocol.py</files>
  <action>
    First, verify that WorkflowConfig model already exists in protocol.py (it should from Phase 3).

    Then add to src/server/routes.py after the /library/load endpoint, add workflow library endpoints:

    ```python
    # Workflow Library Endpoints

    @router.post("/library/save/workflow")
    async def save_workflow_config(req: Dict[str, Any]):
        """
        Save a workflow configuration as a named library template.
        Workflows stored in workflow_library/ directory at project root.
        """
        from pathlib import Path
        from src.engine.protocol import WorkflowConfig
        import json

        try:
            # Parse and validate request using Pydantic
            config = WorkflowConfig(**req)

            # Use workflow_library/ at project root (cross-workflow configs)
            # Or could store next to first file in workflow
            if config.files and len(config.files) > 0:
                first_file = Path(config.files[0].file_path)
                library_dir = first_file.parent.parent / "workflow_library"
            else:
                # Fallback to current directory
                library_dir = Path.cwd() / "workflow_library"

            library_dir.mkdir(exist_ok=True)

            # Sanitize config name for filename
            safe_name = "".join(c for c in config.name if c.isalnum() or c in (' ', '-', '_')).strip()
            config_file = library_dir / f"{safe_name}.json"

            # Convert to relative paths for portability
            # For workflows, store paths relative to library_dir
            config_dict = config.model_dump(mode='json')
            base_path = library_dir.parent

            for file in config_dict.get('files', []):
                if file.get('file_path'):
                    try:
                        rel_path = Path(file['file_path']).relative_to(base_path)
                        file['file_path'] = str(rel_path)
                    except ValueError:
                        # File on different drive - keep absolute
                        pass

            if config_dict.get('output_dir'):
                try:
                    output_rel = Path(config_dict['output_dir']).relative_to(base_path)
                    config_dict['output_dir'] = output_rel
                except ValueError:
                    pass

            # Write JSON file
            config_file.write_text(json.dumps(config_dict, indent=2), encoding='utf-8')

            return {
                "status": "success",
                "config_path": str(config_file),
                "config_name": config.name
            }
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))
    ```

    Then add the list and load endpoints:

    ```python
    @router.get("/library/list/workflows")
    async def list_workflow_configs():
        """
        List all saved workflow configurations.
        Returns metadata (name, path, created_at) for each config.
        """
        from pathlib import Path
        import json

        try:
            library_dir = Path.cwd() / "workflow_library"

            if not library_dir.exists():
                return {"configs": []}

            configs = []
            for config_file in library_dir.glob("*.json"):
                try:
                    config_data = json.loads(config_file.read_text(encoding='utf-8'))
                    configs.append({
                        "name": config_data.get("name", config_file.stem),
                        "path": str(config_file),
                        "created_at": config_data.get("created_at", "unknown"),
                        "files_count": len(config_data.get("files", [])),
                    })
                except Exception:
                    continue

            return {"configs": configs}
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))


    @router.post("/library/load/workflow")
    async def load_workflow_config(req: Dict[str, Any]):
        """
        Load a saved workflow configuration by file path.
        Returns WorkflowConfig with absolute paths resolved.
        """
        from pathlib import Path
        from src.engine.protocol import WorkflowConfig
        import json

        try:
            config_path_str = req.get("config_path")
            if not config_path_str:
                raise HTTPException(status_code=400, detail="Missing config_path")

            config_path = Path(config_path_str)
            if not config_path.exists():
                raise HTTPException(status_code=404, detail=f"Config file not found: {config_path_str}")

            # Read and validate using Pydantic
            config_json = config_path.read_text(encoding='utf-8')
            config_dict = json.loads(config_json)

            # Resolve relative paths to absolute
            base_path = config_path.parent.parent

            for file in config_dict.get('files', []):
                if file.get('file_path'):
                    resolved_path = base_path / file['file_path']
                    file['file_path'] = str(resolved_path.resolve())

            if config_dict.get('output_dir'):
                output_abs = base_path / config_dict['output_dir']
                config_dict['output_dir'] = str(output_abs.resolve())

            # Validate with Pydantic
            config = WorkflowConfig.model_validate(config_dict)

            return config.model_dump(mode='json')
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))
    ```

    This adds workflow-specific endpoints that:
    - Store workflows in workflow_library/ directory
    - Handle multiple files in workflow
    - Resolve paths relative to library location
    - Return file count in metadata
  </action>
  <verify>Python passes: `python -c "from src.server.routes import router; print([r.path for r in router.routes if 'workflow' in r.path])"` shows workflow library endpoints</verify>
  <done>Workflow library endpoints exist for save/list/load operations</done>
</task>

<task type="auto">
  <name>Add workflow library types and API functions to frontend api.ts</name>
  <files>frontend/src/services/api.ts</files>
  <action>
    Add to frontend/src/services/api.ts after loadLibraryConfig function:

    ```typescript
    // Workflow Library Types

    export interface WorkflowLibraryConfigMetadata {
      name: string;
      path: string;
      created_at: string;
      files_count: number;
    }

    export interface ListWorkflowLibraryConfigsResponse {
      configs: WorkflowLibraryConfigMetadata[];
    }

    export interface SaveWorkflowLibraryConfigRequest {
      name: string;
      files: WorkflowFile[];
      mappings: FileMapping[];
      stop_on_error: boolean;
      export_pdf: boolean;
      export_mcdx: boolean;
      output_dir?: string;
    }

    export type LoadWorkflowLibraryConfigResponse = WorkflowConfig;

    // Workflow Library API Functions

    export const saveWorkflowLibraryConfig = async (config: SaveWorkflowLibraryConfigRequest): Promise<SaveLibraryConfigResponse> => {
      const { data } = await api.post<SaveLibraryConfigResponse>('/library/save/workflow', config);
      return data;
    };

    export const listWorkflowLibraryConfigs = async (): Promise<ListWorkflowLibraryConfigsResponse> => {
      const { data } = await api.get<ListWorkflowLibraryConfigsResponse>('/library/list/workflows');
      return data;
    };

    export const loadWorkflowLibraryConfig = async (configPath: string): Promise<LoadWorkflowLibraryConfigResponse> => {
      const { data } = await api.post<LoadWorkflowLibraryConfigResponse>('/library/load/workflow', { config_path: configPath });
      return data;
    };
    ```

    This adds workflow-specific types and API functions.
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for workflow library type errors)</verify>
  <done>Workflow library types and API functions exist in api.ts</done>
</task>

<task type="auto">
  <name>Create useWorkflowLibrary hook</name>
  <files>frontend/src/hooks/useWorkflowLibrary.ts</files>
  <action>
    Create new file frontend/src/hooks/useWorkflowLibrary.ts:

    ```typescript
    import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
    import {
      saveWorkflowLibraryConfig,
      listWorkflowLibraryConfigs,
      loadWorkflowLibraryConfig,
      type SaveWorkflowLibraryConfigRequest,
      type WorkflowLibraryConfigMetadata,
      type LoadWorkflowLibraryConfigResponse,
    } from '../services/api';

    export const useWorkflowLibrary = () => {
      const queryClient = useQueryClient();

      // List all workflow configs
      const {
        data: configs,
        isLoading: isLoadingConfigs,
        error: listError,
        refetch: refetchConfigs,
      } = useQuery<WorkflowLibraryConfigMetadata[]>({
        queryKey: ['library', 'workflows'],
        queryFn: async () => {
          const response = await listWorkflowLibraryConfigs();
          return response.configs;
        },
        staleTime: 5 * 60 * 1000, // Cache for 5 minutes
      });

      // Save a workflow config
      const saveMutation = useMutation({
        mutationFn: (config: SaveWorkflowLibraryConfigRequest) => saveWorkflowLibraryConfig(config),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['library', 'workflows'] });
        },
      });

      // Load a workflow config
      const loadMutation = useMutation({
        mutationFn: (configPath: string) => loadWorkflowLibraryConfig(configPath),
      });

      return {
        // List configs
        configs,
        isLoadingConfigs,
        listError,
        refetchConfigs,

        // Save config
        saveConfig: saveMutation.mutate,
        isSaving: saveMutation.isPending,
        saveError: saveMutation.error,
        saveResult: saveMutation.data,

        // Load config
        loadConfig: loadMutation.mutate,
        isLoadingConfig: loadMutation.isPending,
        loadError: loadMutation.error,
        loadedConfig: loadMutation.data,
      };
    };
    ```

    This hook mirrors useLibrary but for workflow configs.
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for useWorkflowLibrary errors)</verify>
  <done>useWorkflowLibrary hook exists with workflow-specific operations</done>
</task>

<task type="auto">
  <name>Create WorkflowLibraryModal component</name>
  <files>frontend/src/components/WorkflowLibraryModal.tsx</files>
  <action>
    Create new file frontend/src/components/WorkflowLibraryModal.tsx (similar to LibraryModal but for workflows):

    ```typescript
    import {
      Modal,
      Stack,
      Group,
      Button,
      TextInput,
      Text,
      Alert,
      Loader,
      Table,
      Badge,
    } from '@mantine/core';
    import { IconSave, IconX } from '@tabler/icons-react';
    import { useState, useEffect } from 'react';
    import { useWorkflowLibrary } from '../hooks/useWorkflowLibrary';
    import type { WorkflowConfig } from '../services/api';

    interface WorkflowLibraryModalProps {
      opened: boolean;
      onClose: () => void;
      currentWorkflow: WorkflowConfig;
      onLoadWorkflow?: (config: WorkflowConfig) => void;
    }

    export const WorkflowLibraryModal = ({
      opened,
      onClose,
      currentWorkflow,
      onLoadWorkflow,
    }: WorkflowLibraryModalProps) => {
      const [activeTab, setActiveTab] = useState<'save' | 'load'>('load');
      const [saveName, setSaveName] = useState('');
      const [saveSuccess, setSaveSuccess] = useState(false);

      const {
        configs,
        isLoadingConfigs,
        listError,
        refetchConfigs,
        saveConfig,
        isSaving,
        saveError,
        loadConfig,
        isLoadingConfig,
        loadError,
      } = useWorkflowLibrary();

      useEffect(() => {
        if (opened) {
          setSaveName('');
          setSaveSuccess(false);
        }
      }, [opened]);

      const handleSave = () => {
        if (!saveName.trim()) return;

        const configRequest = {
          ...currentWorkflow,
          name: saveName,
        };

        saveConfig(configRequest, {
          onSuccess: (data) => {
            setSaveSuccess(true);
            setTimeout(() => {
              setSaveSuccess(false);
              onClose();
            }, 1500);
          },
        });
      };

      const handleLoad = (configPath: string) => {
        loadConfig(configPath, {
          onSuccess: (config) => {
            if (onLoadWorkflow) {
              onLoadWorkflow(config);
              onClose();
            }
          },
        });
      };

      return (
        <Modal opened={opened} onClose={onClose} title="Workflow Library" size="md">
          <Stack>
            <Group grow>
              <Button
                variant={activeTab === 'load' ? 'filled' : 'light'}
                onClick={() => setActiveTab('load')}
              >
                Load Workflow
              </Button>
              <Button
                variant={activeTab === 'save' ? 'filled' : 'light'}
                onClick={() => setActiveTab('save')}
              >
                Save Workflow
              </Button>
            </Group>

            {activeTab === 'load' && (
              <Stack>
                {isLoadingConfigs && <Loader />}
                {listError && (
                  <Alert color="red">Error loading workflows: {(listError as Error).message}</Alert>
                )}
                {!isLoadingConfigs && configs && configs.length === 0 && (
                  <Text c="dimmed">No saved workflows found.</Text>
                )}
                {configs && configs.length > 0 && (
                  <Table>
                    <Table.Thead>
                      <Table.Tr>
                        <Table.Th>Name</Table.Th>
                        <Table.Th>Files</Table.Th>
                        <Table.Th>Created</Table.Th>
                        <Table.Th>Action</Table.Th>
                      </Table.Tr>
                    </Table.Thead>
                    <Table.Tbody>
                      {configs.map((config) => (
                        <Table.Tr key={config.path}>
                          <Table.Td>{config.name}</Table.Td>
                          <Table.Td>{config.files_count}</Table.Td>
                          <Table.Td>{new Date(config.created_at).toLocaleDateString()}</Table.Td>
                          <Table.Td>
                            <Button
                              size="xs"
                              onClick={() => handleLoad(config.path)}
                              loading={isLoadingConfig}
                            >
                              Load
                            </Button>
                          </Table.Td>
                        </Table.Tr>
                      ))}
                    </Table.Tbody>
                  </Table>
                )}
                {loadError && (
                  <Alert color="red">Error loading workflow: {(loadError as Error).message}</Alert>
                )}
              </Stack>
            )}

            {activeTab === 'save' && (
              <Stack>
                <TextInput
                  label="Workflow Name"
                  placeholder="e.g., Steel Beam Design, Multi-stage Analysis"
                  value={saveName}
                  onChange={(e) => setSaveName(e.currentTarget.value)}
                />
                <Group>
                  <Button onClick={handleSave} loading={isSaving} leftSection={<IconSave size={16} />}>
                    Save Workflow
                  </Button>
                  {saveSuccess && (
                    <Badge color="green">Saved successfully!</Badge>
                  )}
                </Group>
                {saveError && (
                  <Alert color="red">Error saving workflow: {(saveError as Error).message}</Alert>
                )}
                <Text size="xs" c="dimmed">
                  This will save the current workflow (files, mappings, export settings) to the library.
                </Text>
              </Stack>
            )}
          </Stack>
        </Modal>
      );
    };
    ```

    This mirrors LibraryModal but for workflow configs.
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for WorkflowLibraryModal errors)</verify>
  <done>WorkflowLibraryModal component exists with save/load workflow tabs</done>
</task>

<task type="auto">
  <name>Integrate WorkflowLibraryModal into App.tsx</name>
  <files>frontend/src/App.tsx</files>
  <action>
    Modify frontend/src/App.tsx to add workflow library functionality:

    1. Add import after LibraryModal import:
    ```typescript
    import { WorkflowLibraryModal } from './components/WorkflowLibraryModal'
    ```

    2. Add state variable after libraryOpened:
    ```typescript
    const [workflowLibraryOpened, setWorkflowLibraryOpened] = useState(false);
    ```

    3. Add handler after handleLoadLibraryConfig:
    ```typescript
    const handleLoadWorkflowLibrary = (config: WorkflowConfig) => {
      setWorkflowFiles(config.files);
      setWorkflowMappings(config.mappings);
      setWorkflowExportPdf(config.export_pdf);
      setWorkflowExportMcdx(config.export_mcdx);
    };
    ```

    4. Add "Library" button to Workflow tab (find the Group with workflow run button):
    ```typescript
    <Button onClick={() => setWorkflowLibraryOpened(true)} variant="light">
      Library
    </Button>
    ```

    5. Add WorkflowLibraryModal at end of App return (after LibraryModal):
    ```typescript
    <WorkflowLibraryModal
      opened={workflowLibraryOpened}
      onClose={() => setWorkflowLibraryOpened(false)}
      currentWorkflow={{
        name: `workflow-${Date.now()}`,
        files: workflowFiles,
        mappings: workflowMappings,
        stop_on_error: true,
        export_pdf: workflowExportPdf,
        export_mcdx: workflowExportMcdx,
      }}
      onLoadWorkflow={handleLoadWorkflowLibrary}
    />
    ```

    This integrates workflow library into the Workflow tab.
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for workflow library integration errors)</verify>
  <done>App.tsx has workflow library button, modal, and load handler</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete workflow library save/load UI in Workflow tab</what-built>
  <how-to-verify>
    1. Navigate to Workflow tab in UI
    2. Add 2-3 files to workflow
    3. Add mappings between files
    4. Configure export settings
    5. Click "Library" button in Workflow tab
    6. **TEST SAVE**: Enter name "Test Workflow", click Save
    7. Verify success badge and modal closes
    8. Re-open Workflow Library modal
    9. **TEST LOAD**: Verify "Test Workflow" appears in table
    10. Click "Load" button
    11. Verify files and mappings populate correctly
    12. Verify export settings restored
    13. Try loading workflow into empty workflow state
  </how-to-verify>
  <resume-signal>Type "approved" if workflow library works correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
## Workflow Library Verification

1. **Backend Endpoints**:
   - POST /library/save/workflow saves WorkflowConfig
   - GET /library/list/workflows returns workflow metadata
   - POST /library/load/workflow loads full config

2. **Frontend Integration**:
   - WorkflowLibraryModal opens from Workflow tab
   - Save stores workflow in workflow_library/
   - Load populates files, mappings, export settings

3. **Path Resolution**:
   - Workflow file paths resolved correctly
   - Mappings preserved across save/load
   - Export settings restored

4. **Edge Cases**:
   - Empty workflow (no files)
   - Workflow with many files (10+)
   - Special characters in workflow name
</verification>

<success_criteria>
1. Workflow library button visible in Workflow tab
2. WorkflowLibraryModal has Save/Load tabs
3. Save tab accepts name and saves workflow config
4. Load tab shows table with file count
5. Load button restores complete workflow (files + mappings + settings)
6. Success/error states display properly
7. No console errors during workflow library operations
8. Workflow configs persist in workflow_library/ directory
</success_criteria>

<output>
After completion, create `.planning/phases/04-library-persistence/04-05-SUMMARY.md` with:
- Workflow library backend endpoints
- WorkflowLibraryModal component structure
- Workflow library integration in App.tsx
- Path resolution for multi-file workflows
- User feedback from checkpoint
</output>
