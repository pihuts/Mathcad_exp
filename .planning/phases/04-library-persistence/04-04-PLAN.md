---
phase: 04-library-persistence
plan: 04
type: execute
wave: 2
depends_on:
  - 04-03
files_modified:
  - frontend/src/components/LibraryModal.tsx
  - frontend/src/App.tsx
autonomous: false

must_haves:
  truths:
    - "User can open library modal and see list of saved configs"
    - "User can save current batch configuration with custom name"
    - "User can load a saved config to populate input fields"
    - "UI shows loading/error states for library operations"
  artifacts:
    - path: "frontend/src/components/LibraryModal.tsx"
      provides: "Modal component for save/load library operations"
      contains: "export const LibraryModal"
    - path: "frontend/src/App.tsx"
      provides: "Library button and modal integration in Batch tab"
      contains: "LibraryModal"
  key_links:
    - from: "frontend/src/components/LibraryModal.tsx"
      to: "frontend/src/hooks/useLibrary.ts"
      via: "const { configs, saveConfig, loadConfig, ... } = useLibrary(filePath)"
      pattern: "useLibrary\("
    - from: "frontend/src/App.tsx"
      to: "frontend/src/components/LibraryModal.tsx"
      via: "import { LibraryModal } from './components/LibraryModal'"
      pattern: "import.*LibraryModal"
---

<objective>
Create UI modal for library save/load operations and integrate into Batch tab.

Purpose: Provide user interface for saving current configurations and loading saved templates.
Output: Working LibraryModal component with save/load functionality integrated into App.tsx.
</objective>

<execution_context>
@C:\Users\peter\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\peter\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-library-persistence/04-01-PLAN.md
@.planning/phases/04-library-persistence/04-02-PLAN.md
@.planning/phases/04-library-persistence/04-03-PLAN.md
@frontend/src/components/InputModal.tsx
@frontend/src/App.tsx
@frontend/src/hooks/useBatch.ts

# Research-backed decisions
@.planning/phases/04-library-persistence/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create LibraryModal component</name>
  <files>frontend/src/components/LibraryModal.tsx</files>
  <action>
    Create new file frontend/src/components/LibraryModal.tsx:

    ```typescript
    import {
      Modal,
      Stack,
  Group,
      Button,
      TextInput,
      ActionIcon,
      Text,
      Alert,
      Loader,
      Table,
      Badge,
    } from '@mantine/core';
    import { IconTrash, IconFolder, IconSave, IconX } from '@tabler/icons-react';
    import { useState, useEffect } from 'react';
    import { useLibrary } from '../hooks/useLibrary';
    import type { InputConfig } from '../services/api';

    interface LibraryModalProps {
      opened: boolean;
      onClose: () => void;
      filePath: string;
      currentInputs: Record<string, any[]>; // Current alias configs from App state
      exportPdf: boolean;
      exportMcdx: boolean;
      outputDir?: string;
      onLoadConfig?: (config: { inputs: InputConfig[]; exportPdf: boolean; exportMcdx: boolean }) => void;
    }

    export const LibraryModal = ({
      opened,
      onClose,
      filePath,
      currentInputs,
      exportPdf,
      exportMcdx,
      outputDir,
      onLoadConfig,
    }: LibraryModalProps) => {
      const [activeTab, setActiveTab] = useState<'save' | 'load'>('load');
      const [saveName, setSaveName] = useState('');
      const [saveSuccess, setSaveSuccess] = useState(false);

      const {
        configs,
        isLoadingConfigs,
        listError,
        refetchConfigs,
        saveConfig,
        isSaving,
        saveError,
        loadConfig,
        isLoadingConfig,
        loadError,
      } = useLibrary(filePath);

      // Reset save state when modal opens
      useEffect(() => {
        if (opened) {
          setSaveName('');
          setSaveSuccess(false);
        }
      }, [opened]);

      const handleSave = () => {
        if (!saveName.trim()) return;

        // Convert currentInputs to InputConfig[]
        const inputConfigs: InputConfig[] = Object.entries(currentInputs).flatMap(([alias, configs]) => {
          const firstConfig = configs[0];
          if (!firstConfig) return [];

          // Handle both InputConfig objects and plain values
          if (typeof firstConfig === 'object' && 'value' in firstConfig) {
            return [{ alias, value: firstConfig.value, units: firstConfig.units }];
          }
          return [{ alias, value: firstConfig }];
        });

        const configRequest = {
          name: saveName,
          file_path: filePath,
          inputs: inputConfigs,
          export_pdf: exportPdf,
          export_mcdx: exportMcdx,
          output_dir: outputDir,
        };

        saveConfig(configRequest, {
          onSuccess: (data) => {
            setSaveSuccess(true);
            setTimeout(() => {
              setSaveSuccess(false);
              onClose();
            }, 1500);
          },
        });
      };

      const handleLoad = (configPath: string) => {
        loadConfig(configPath, {
          onSuccess: (config) => {
            if (onLoadConfig) {
              onLoadConfig({
                inputs: config.inputs,
                exportPdf: config.export_pdf,
                exportMcdx: config.export_mcdx,
              });
              onClose();
            }
          },
        });
      };

      return (
        <Modal opened={opened} onClose={onClose} title="Library" size="md">
          <Stack>
            <Group grow>
              <Button
                variant={activeTab === 'load' ? 'filled' : 'light'}
                onClick={() => setActiveTab('load')}
              >
                Load Config
              </Button>
              <Button
                variant={activeTab === 'save' ? 'filled' : 'light'}
                onClick={() => setActiveTab('save')}
              >
                Save Config
              </Button>
            </Group>

            {activeTab === 'load' && (
              <Stack>
                {isLoadingConfigs && <Loader />}
                {listError && (
                  <Alert color="red">Error loading configs: {(listError as Error).message}</Alert>
                )}
                {!isLoadingConfigs && configs && configs.length === 0 && (
                  <Text c="dimmed">No saved configurations found for this file.</Text>
                )}
                {configs && configs.length > 0 && (
                  <Table>
                    <Table.Thead>
                      <Table.Tr>
                        <Table.Th>Name</Table.Th>
                        <Table.Th>Created</Table.Th>
                        <Table.Th>Action</Table.Th>
                      </Table.Tr>
                    </Table.Thead>
                    <Table.Tbody>
                      {configs.map((config) => (
                        <Table.Tr key={config.path}>
                          <Table.Td>{config.name}</Table.Td>
                          <Table.Td>{new Date(config.created_at).toLocaleDateString()}</Table.Td>
                          <Table.Td>
                            <Button
                              size="xs"
                              onClick={() => handleLoad(config.path)}
                              loading={isLoadingConfig}
                            >
                              Load
                            </Button>
                          </Table.Td>
                        </Table.Tr>
                      ))}
                    </Table.Tbody>
                  </Table>
                )}
                {loadError && (
                  <Alert color="red">Error loading config: {(loadError as Error).message}</Alert>
                )}
              </Stack>
            )}

            {activeTab === 'save' && (
              <Stack>
                <TextInput
                  label="Configuration Name"
                  placeholder="e.g., Bolt Diameters, Load Case 1"
                  value={saveName}
                  onChange={(e) => setSaveName(e.currentTarget.value)}
                />
                <Group>
                  <Button onClick={handleSave} loading={isSaving} leftSection={<IconSave size={16} />}>
                    Save Configuration
                  </Button>
                  {saveSuccess && (
                    <Badge color="green">Saved successfully!</Badge>
                  )}
                </Group>
                {saveError && (
                  <Alert color="red">Error saving config: {(saveError as Error).message}</Alert>
                )}
                <Text size="xs" c="dimmed">
                  This will save the current input configuration to a library template for reuse.
                </Text>
              </Stack>
            )}
          </Stack>
        </Modal>
      );
    };
    ```

    This component:
    - Two-tab modal (Save/Load)
    - Save tab: Name input + save button, shows success badge
    - Load tab: Table of saved configs with Load buttons
    - Integrates useLibrary hook for API calls
    - onLoadConfig callback returns loaded config to App
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for LibraryModal errors)</verify>
  <done>LibraryModal component exists with save/load tabs and table of configs</done>
</task>

<task type="auto">
  <name>Integrate LibraryModal into App.tsx Batch tab</name>
  <files>frontend/src/App.tsx</files>
  <action>
    Modify frontend/src/App.tsx to add library functionality:

    1. Add import after other component imports (around line 10):
    ```typescript
    import { LibraryModal } from './components/LibraryModal'
    ```

    2. Add state variables after exportMcdx state (around line 29):
    ```typescript
    const [libraryOpened, setLibraryOpened] = useState(false);
    ```

    3. Add handler function after handleRunWorkflow (around line 132):
    ```typescript
    const handleLoadLibraryConfig = (config: {
      inputs: InputConfig[];
      exportPdf: boolean;
      exportMcdx: boolean;
    }) => {
      // Convert InputConfig[] back to aliasConfigs structure
      const newAliasConfigs: Record<string, any[]> = {};

      config.inputs.forEach((inputConfig) => {
        newAliasConfigs[inputConfig.alias] = [{ value: inputConfig.value, units: inputConfig.units }];
      });

      setAliasConfigs(newAliasConfigs);
      setExportPdf(config.exportPdf);
      setExportMcdx(config.exportMcdx);
    };
    ```

    4. Add Library button to Batch tab after the "Start Batch" button (find the Group with start button):
    ```typescript
    <Button onClick={() => setLibraryOpened(true)} variant="light" leftSection={<IconFolder size={16} />}>
      Library
    </Button>
    ```

    5. Add LibraryModal component at end of App return (before closing AppShell):
    ```typescript
    <LibraryModal
      opened={libraryOpened}
      onClose={() => setLibraryOpened(false)}
      filePath={filePath}
      currentInputs={aliasConfigs}
      exportPdf={exportPdf}
      exportMcdx={exportMcdx}
      outputDir={undefined} // Or add outputDir state if needed
      onLoadConfig={handleLoadLibraryConfig}
    />
    ```

    6. Add IconFolder to imports if not present:
    ```typescript
    import { IconSettings, IconAlertCircle, IconFile, IconFolder } from '@tabler/icons-react'
    ```

    This integrates library save/load into the Batch workflow.
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for App.tsx integration errors)</verify>
  <done>App.tsx has Library button, LibraryModal component, and handleLoadLibraryConfig function</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete library save/load UI in Batch tab</what-built>
  <how-to-verify>
    1. Start backend: `python -m src.server.main`
    2. Start frontend: `cd frontend && npm run dev`
    3. Open browser to http://localhost:5173
    4. Browse and analyze a Mathcad file
    5. Configure some inputs (add ranges or values)
    6. Click "Library" button
    7. **TEST SAVE**: Enter name "Test Config", click Save
    8. Verify success badge appears and modal closes
    9. Re-open Library modal
    10. **TEST LOAD**: Verify "Test Config" appears in table
    11. Click "Load" button
    12. Verify inputs populate correctly in main UI
    13. Clear inputs, try loading again to confirm reload works
  </how-to-verify>
  <resume-signal>Type "approved" if library save/load works correctly, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
## UI Integration Verification

1. **Manual Testing** (see checkpoint above):
   - Save current configuration
   - Load saved configuration
   - Verify inputs populate correctly
   - Verify export settings persist

2. **Edge Cases**:
   - Empty inputs state
   - No configs directory exists (should show "No saved configurations")
   - Special characters in config name
   - Very long config names

3. **Error Handling**:
   - Backend offline (should show error message)
   - Corrupted config files (should skip in list)
   - Invalid JSON (should show error alert)
</verification>

<success_criteria>
1. Library button visible in Batch tab
2. LibraryModal opens with Save/Load tabs
3. Save tab accepts name and successfully saves config
4. Load tab shows table of saved configs
5. Load button populates inputs in main UI
6. Success/error states display properly
7. Modal closes after successful save/load
8. No console errors during library operations
</success_criteria>

<output>
After completion, create `.planning/phases/04-library-persistence/04-04-SUMMARY.md` with:
- LibraryModal component structure
- App.tsx integration points
- User flow for save/load
- Any UI/UX refinements made
- User feedback from checkpoint
</output>
