---
phase: 04-library-persistence
plan: 03
type: execute
wave: 2
depends_on:
  - 04-02
files_modified:
  - frontend/src/services/api.ts
  - frontend/src/hooks/useLibrary.ts
autonomous: true

must_haves:
  truths:
    - "Frontend can call library save/list/load APIs"
    - "useLibrary hook provides library operations"
    - "TypeScript types match backend schemas"
  artifacts:
    - path: "frontend/src/services/api.ts"
      provides: "saveLibraryConfig, listLibraryConfigs, loadLibraryConfig functions"
      exports: ["saveLibraryConfig", "listLibraryConfigs", "loadLibraryConfig"]
    - path: "frontend/src/hooks/useLibrary.ts"
      provides: "React Query hook for library operations"
      exports: ["useLibrary"]
  key_links:
    - from: "frontend/src/services/api.ts"
      to: "/api/v1/library/*"
      via: "axios.post() and axios.get() calls"
      pattern: "api\.post\('/library/"
    - from: "frontend/src/hooks/useLibrary.ts"
      to: "frontend/src/services/api.ts"
      via: "import { saveLibraryConfig, listLibraryConfigs, loadLibraryConfig }"
      pattern: "from.*api.*import.*saveLibraryConfig"
---

<objective>
Create frontend API service and React Query hook for library operations.

Purpose: Provide type-safe frontend access to library save/list/load endpoints with caching and error handling.
Output: Working api.ts functions and useLibrary hook for library operations.
</objective>

<execution_context>
@C:\Users\peter\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\peter\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-library-persistence/04-01-PLAN.md
@.planning/phases/04-library-persistence/04-02-PLAN.md
@frontend/src/services/api.ts
@frontend/src/hooks/useBatch.ts

# Research-backed decisions
@.planning/phases/04-library-persistence/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Add library TypeScript types and API functions to api.ts</name>
  <files>frontend/src/services/api.ts</files>
  <action>
    Add to frontend/src/services/api.ts after the browseFile export (around line 152):

    ```typescript
    // Library Types

    export interface LibraryConfigMetadata {
      name: string;
      path: string;
      created_at: string;
      version: string;
    }

    export interface ListLibraryConfigsResponse {
      configs: LibraryConfigMetadata[];
    }

    export interface SaveLibraryConfigRequest {
      name: string;
      file_path: string;
      inputs: InputConfig[];
      export_pdf: boolean;
      export_mcdx: boolean;
      output_dir?: string;
    }

    export interface SaveLibraryConfigResponse {
      status: string;
      config_path: string;
      config_name: string;
    }

    export interface LoadLibraryConfigRequest {
      config_path: string;
    }

    export type LoadLibraryConfigResponse = SaveLibraryConfigRequest; // BatchConfig structure

    // Library API Functions

    export const saveLibraryConfig = async (config: SaveLibraryConfigRequest): Promise<SaveLibraryConfigResponse> => {
      const { data } = await api.post<SaveLibraryConfigResponse>('/library/save', config);
      return data;
    };

    export const listLibraryConfigs = async (filePath: string): Promise<ListLibraryConfigsResponse> => {
      const { data } = await api.get<ListLibraryConfigsResponse>('/library/list', {
        params: { file_path: filePath }
      });
      return data;
    };

    export const loadLibraryConfig = async (configPath: string): Promise<LoadLibraryConfigResponse> => {
      const { data } = await api.post<LoadLibraryConfigResponse>('/library/load', { config_path: configPath });
      return data;
    };
    ```

    Then update the default export to include these new functions (they're already exported above).

    This adds:
    - TypeScript interfaces matching backend schemas exactly
    - Three API functions using axios
    - Proper typing for request/response
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for type errors)</verify>
  <done>Library types and API functions exist in api.ts with correct TypeScript types</done>
</task>

<task type="auto">
  <name>Create useLibrary React Query hook</name>
  <files>frontend/src/hooks/useLibrary.ts</files>
  <action>
    Create new file frontend/src/hooks/useLibrary.ts:

    ```typescript
    import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
    import {
      saveLibraryConfig,
      listLibraryConfigs,
      loadLibraryConfig,
      type SaveLibraryConfigRequest,
      type LibraryConfigMetadata,
      type LoadLibraryConfigResponse,
    } from '../services/api';

    export const useLibrary = (filePath?: string) => {
      const queryClient = useQueryClient();

      // List all configs for a given file
      const {
        data: configs,
        isLoading: isLoadingConfigs,
        error: listError,
        refetch: refetchConfigs,
      } = useQuery<LibraryConfigMetadata[]>({
        queryKey: ['library', 'list', filePath],
        queryFn: async () => {
          if (!filePath) return [];
          const response = await listLibraryConfigs(filePath);
          return response.configs;
        },
        enabled: !!filePath, // Only run if filePath provided
        staleTime: 5 * 60 * 1000, // Cache for 5 minutes
      });

      // Save a config
      const saveMutation = useMutation({
        mutationFn: (config: SaveLibraryConfigRequest) => saveLibraryConfig(config),
        onSuccess: (data) => {
          // Invalidate and refetch configs list
          if (filePath) {
            queryClient.invalidateQueries({ queryKey: ['library', 'list', filePath] });
          }
          return data;
        },
      });

      // Load a config
      const loadMutation = useMutation({
        mutationFn: (configPath: string) => loadLibraryConfig(configPath),
      });

      return {
        // List configs
        configs,
        isLoadingConfigs,
        listError,
        refetchConfigs,

        // Save config
        saveConfig: saveMutation.mutate,
        isSaving: saveMutation.isPending,
        saveError: saveMutation.error,
        saveResult: saveMutation.data,

        // Load config
        loadConfig: loadMutation.mutate,
        isLoadingConfig: loadMutation.isPending,
        loadError: loadMutation.error,
        loadedConfig: loadMutation.data,
      };
    };
    ```

    This hook provides:
    - Cached listing of configs (5-min cache)
    - Mutations for save/load operations
    - Automatic invalidation of list after save
    - Loading/error states for UI binding
  </action>
  <verify>frontend builds: `cd frontend && npm run build` (check for useLibrary import errors)</verify>
  <done>useLibrary hook exists with list/save/load operations and React Query caching</done>
</task>

</tasks>

<verification>
## Frontend Library Hook Verification

1. **TypeScript Compilation**:
   ```bash
   cd frontend && npm run build
   # Should complete without type errors
   ```

2. **Import Test**:
   - Verify api.ts exports new functions
   - Verify useLibrary can be imported
   - No "Cannot find module" errors

3. **Manual Testing** (after UI integration in plan 04):
   - Call useLibrary hook with filePath
   - Verify configs array loads
   - Verify save/load mutations work
</verification>

<success_criteria>
1. api.ts has saveLibraryConfig, listLibraryConfigs, loadLibraryConfig functions
2. TypeScript interfaces match backend schemas exactly
3. useLibrary hook provides list/save/load operations
4. useLibrary uses React Query for caching
5. List query invalidates after successful save
6. Frontend builds without type errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-library-persistence/04-03-SUMMARY.md` with:
- TypeScript types added to api.ts
- API function implementations
- useLibrary hook structure and caching strategy
- Any type mapping decisions
</output>
