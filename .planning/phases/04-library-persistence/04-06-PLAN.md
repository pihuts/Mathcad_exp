---
phase: 04-library-persistence
plan: 06
type: execute
wave: 4
depends_on:
  - 04-04
  - 04-05
files_modified: []
autonomous: false

must_haves:
  truths:
    - "User can save batch configuration and reload it later"
    - "User can save workflow configuration and reload it later"
    - "Configs persist across application restarts"
    - "Configs can be shared between users (via file transfer)"
    - "String input types preserved through save/load"
    - "Units specifications preserved through save/load"
  artifacts:
    - path: ".planning/phases/04-library-persistence/04-06-VERIFICATION.md"
      provides: "Verification test results and acceptance criteria"
      contains: "## Verification Results"
  key_links:
    - from: "Verification tests"
      to: "BatchConfig and WorkflowConfig models"
      via: "Pydantic validation and JSON serialization"
      pattern: "\.model_dump\(\)|\.model_validate\("
---

<objective>
Perform end-to-end verification of library persistence feature to ensure save/load operations work correctly for both batch and workflow configurations.

Purpose: Validate that library system meets all requirements and handles edge cases correctly before marking phase complete.
Output: Comprehensive verification results confirming feature works as specified.
</objective>

<execution_context>
@C:\Users\peter\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\peter\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-library-persistence/04-01-PLAN.md
@.planning/phases/04-library-persistence/04-02-PLAN.md
@.planning/phases/04-library-persistence/04-03-PLAN.md
@.planning/phases/04-library-persistence/04-04-PLAN.md
@.planning/phases/04-library-persistence/04-05-PLAN.md
@.planning/phases/04-library-persistence/04-RESEARCH.md

# All prior plan summaries for context
</context>

<tasks>

<task type="auto">
  <name>Verify backend JSON serialization and Pydantic validation</name>
  <files>src/engine/protocol.py, src/server/routes.py</files>
  <action>
    Create test script to verify backend save/load round-trip:

    1. Create test script `tests/test_library_serialization.py`:
    ```python
    import json
    from pathlib import Path
    from src.engine.protocol import BatchConfig, WorkflowConfig, InputConfig

    def test_batch_config_serialization():
        """Test BatchConfig JSON round-trip"""
        config = BatchConfig(
            name="Test Config",
            file_path="test.mcdx",
            inputs=[
                InputConfig(alias="num_input", value=1.5, units="in"),
                InputConfig(alias="str_input", value="A36"),
            ],
            export_pdf=True,
            export_mcdx=False,
        )

        # Dump to JSON
        config_json = config.model_dump(mode='json')
        json_str = json.dumps(config_json, indent=2)
        print("BatchConfig JSON:")
        print(json_str)

        # Load from JSON
        loaded_dict = json.loads(json_str)
        loaded_config = BatchConfig.model_validate(loaded_dict)

        # Verify
        assert loaded_config.name == config.name
        assert len(loaded_config.inputs) == len(config.inputs)
        assert loaded_config.inputs[0].alias == "num_input"
        assert loaded_config.inputs[0].value == 1.5
        assert loaded_config.inputs[0].units == "in"
        assert loaded_config.inputs[1].alias == "str_input"
        assert loaded_config.inputs[1].value == "A36"

        print("✓ BatchConfig serialization test passed")

    def test_workflow_config_serialization():
        """Test WorkflowConfig JSON round-trip"""
        config = WorkflowConfig(
            name="Test Workflow",
            files=[
                {
                    "file_path": "file1.mcdx",
                    "inputs": [
                        InputConfig(alias="input1", value=10.0),
                        InputConfig(alias="input2", value="string_val"),
                    ],
                    "position": 0,
                }
            ],
            mappings=[
                {
                    "source_file": "file1.mcdx",
                    "source_alias": "output1",
                    "target_file": "file2.mcdx",
                    "target_alias": "input2",
                }
            ],
            stop_on_error=True,
            export_pdf=True,
            export_mcdx=True,
        )

        # Dump to JSON
        config_json = config.model_dump(mode='json')
        json_str = json.dumps(config_json, indent=2)
        print("\nWorkflowConfig JSON:")
        print(json_str)

        # Load from JSON
        loaded_dict = json.loads(json_str)
        loaded_config = WorkflowConfig.model_validate(loaded_dict)

        # Verify
        assert loaded_config.name == config.name
        assert len(loaded_config.files) == len(config.files)
        assert len(loaded_config.mappings) == len(config.mappings)
        assert loaded_config.files[0].inputs[0].value == 10.0
        assert loaded_config.files[0].inputs[1].value == "string_val"

        print("✓ WorkflowConfig serialization test passed")

    if __name__ == "__main__":
        test_batch_config_serialization()
        test_workflow_config_serialization()
        print("\n✓ All serialization tests passed")
    ```

    2. Run the test:
    ```bash
    python tests/test_library_serialization.py
    ```

    This verifies:
    - Pydantic models serialize to JSON correctly
    - Numeric and string inputs preserve types
    - Units are preserved
    - Workflow mappings preserved
    - Round-trip (dump -> load -> validate) works
  </action>
  <verify>Test script runs and prints "✓ All serialization tests passed"</verify>
  <done>Backend serialization verified for both BatchConfig and WorkflowConfig with type preservation</done>
</task>

<task type="auto">
  <name>Verify frontend TypeScript types match backend schemas</name>
  <files>frontend/src/services/api.ts</files>
  <action>
    Run frontend build to check for type errors:

    ```bash
    cd frontend
    npm run build
    ```

    Check console for:
    - Type mismatches between frontend and backend
    - Missing properties in interfaces
    - Any TypeScript errors related to library types

    Also verify by spot-checking:
    1. BatchConfig fields match SaveLibraryConfigRequest
    2. WorkflowConfig fields match SaveWorkflowLibraryConfigRequest
    3. Response types match backend schemas

    If issues found, fix TypeScript interfaces to match backend exactly.
  </action>
  <verify>Frontend builds successfully with no type errors related to library</verify>
  <done>Frontend and backend types are aligned</done>
</task>

<task type="auto">
  <name>Verify file storage and path resolution</name>
  <files>src/server/routes.py</files>
  <action>
    Create test to verify path resolution logic:

    1. Create test script `tests/test_library_paths.py`:
    ```python
    from pathlib import Path
    import json

    def test_relative_path_resolution():
        """Test that paths are stored as relative and resolved as absolute"""

        # Simulate save operation
        mcdx_path = Path("C:/Projects/test.mcdx")
        config_dir = mcdx_path.parent / f"{mcdx_path.stem}_configs"

        # Store as relative
        relative_file = mcdx_path.name  # "test.mcdx"
        print(f"Relative path: {relative_file}")

        # Simulate load operation
        loaded_file = config_dir.parent / relative_file
        resolved = loaded_file.resolve()
        print(f"Resolved path: {resolved}")

        # Verify round-trip
        assert resolved == mcdx_path.resolve()
        print("✓ Path resolution test passed")

    def test_config_directory_creation():
        """Test that config directories are created correctly"""

        mcdx_path = Path("C:/Projects/test.mcdx")
        config_dir = mcdx_path.parent / f"{mcdx_path.stem}_configs"

        print(f"Config directory: {config_dir}")
        print(f"Expected: C:/Projects/test_configs/")

        assert config_dir.name == "test_configs"
        assert config_dir.parent == mcdx_path.parent
        print("✓ Config directory naming test passed")

    def test_workflow_library_location():
        """Test workflow library directory location"""

        # First file in workflow
        first_file = Path("C:/Projects/workflows/file1.mcdx")
        library_dir = first_file.parent.parent / "workflow_library"

        print(f"Workflow library: {library_dir}")
        print(f"Expected: C:/Projects/workflow_library/")

        assert library_dir.name == "workflow_library"
        assert library_dir.parent == Path("C:/Projects")
        print("✓ Workflow library location test passed")

    if __name__ == "__main__":
        test_relative_path_resolution()
        test_config_directory_creation()
        test_workflow_library_location()
        print("\n✓ All path tests passed")
    ```

    2. Run the test:
    ```bash
    python tests/test_library_paths.py
    ```

    This verifies:
    - Batch configs stored in {filename}_configs/
    - Workflow configs stored in workflow_library/
    - Relative paths resolve correctly
  </action>
  <verify>All path tests pass with ✓ marks</verify>
  <done>File storage pattern and path resolution verified</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete library persistence system (backend + frontend)</what-built>
  <how-to-verify>
    Perform comprehensive manual testing:

    **BATCH LIBRARY TESTS:**

    1. **Save Batch Config**
    - Open a Mathcad file with numeric and string inputs
    - Configure inputs: Range (0-10 step 1), Single string value, Units (in)
    - Click Library -> Save tab
    - Name: "Comprehensive Test Config"
    - Click Save
    - Verify: Success badge, modal closes, no errors

    2. **Load Batch Config**
    - Clear all inputs
    - Click Library -> Load tab
    - Select "Comprehensive Test Config"
    - Click Load
    - Verify: All inputs restored (range, string, units)
    - Verify: Export settings restored

    3. **Persistence Test**
    - Restart application (close and reopen)
    - Open same Mathcad file
    - Click Library -> Load tab
    - Verify: "Comprehensive Test Config" still listed

    **WORKFLOW LIBRARY TESTS:**

    4. **Save Workflow Config**
    - Create 3-file workflow with mappings
    - Configure inputs on each file
    - Click Library -> Save tab
    - Name: "3-Stage Analysis Workflow"
    - Click Save
    - Verify: Success badge, modal closes

    5. **Load Workflow Config**
    - Clear workflow (remove all files)
    - Click Library -> Load tab
    - Select "3-Stage Analysis Workflow"
    - Click Load
    - Verify: All 3 files restored
    - Verify: All mappings restored
    - Verify: Input configs restored
    - Verify: Export settings restored

    6. **Persistence Test**
    - Restart application
    - Navigate to Workflow tab
    - Click Library -> Load tab
    - Verify: "3-Stage Analysis Workflow" still listed

    **EDGE CASE TESTS:**

    7. **Special Characters in Name**
    - Try saving config with name: "Test @#$ Config"
    - Verify: Saved with sanitized name (special chars removed)
    - Verify: Can load successfully

    8. **Empty Config**
    - Try saving batch config with no inputs configured
    - Verify: Saves without error
    - Verify: Can load (empty config)

    9. **Cross-Machine Portability**
    - Locate saved config JSON file in {filename}_configs/
    - Copy JSON file to another location
    - Manually verify paths are relative (not absolute C:/...)
    - Verify file structure matches schema

    10. **Type Preservation**
    - Save config with numeric inputs and string inputs
    - Load config
    - Verify: Numeric inputs still numeric (not strings)
    - Verify: String inputs still strings (not numbers)
    - Verify: Units preserved on numeric inputs
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe specific failures</resume-signal>
</task>

</tasks>

<verification>
## End-to-End Verification Checklist

### Backend Tests
- [ ] BatchConfig serializes to JSON correctly
- [ ] WorkflowConfig serializes to JSON correctly
- [ ] Numeric types preserved through round-trip
- [ ] String types preserved through round-trip
- [ ] Units preserved through round-trip
- [ ] Config directories created with correct naming
- [ ] Relative paths resolve to absolute correctly

### Frontend Tests
- [ ] TypeScript types match backend schemas
- [ ] Frontend builds without errors
- [ ] Library modal opens from Batch tab
- [ ] Library modal opens from Workflow tab
- [ ] Save operations complete without errors
- [ ] Load operations populate UI correctly

### Integration Tests
- [ ] Batch config save/load works end-to-end
- [ ] Workflow config save/load works end-to-end
- [ ] Configs persist across application restarts
- [ ] Special characters in names handled gracefully
- [ ] Empty configs can be saved/loaded
- [ ] Type preservation verified (number/string)
- [ ] Units preservation verified
- [ ] Export settings preserved

### Documentation
- [ ] All SUMMARY.md files created from plans 01-05
- [ ] Phase ready for handoff or next phase
</verification>

<success_criteria>
1. All backend tests pass (serialization, paths, validation)
2. All frontend tests pass (build, types, UI)
3. All manual verification tests pass (save/load, persistence, edge cases)
4. No regressions in existing batch/workflow functionality
5. User can successfully save and load configs without errors
6. Config files stored in correct directories with relative paths
7. Type preservation verified for both numeric and string inputs
</success_criteria>

<output>
After completion, create `.planning/phases/04-library-persistence/04-06-SUMMARY.md` with:
- Complete verification results (all test outcomes)
- List of any issues found and resolutions
- Confirmation that all success criteria met
- Performance observations (if any)
- Recommendations for future enhancements (if any)
- Final sign-off on Phase 4 completion
</output>
