# Phase 3.3: String Inputs - Research

**Researched:** January 27, 2026
**Domain:** Mixed input type handling (string and numeric)
**Confidence:** HIGH

## Summary

Research investigated extending the current numeric-only input system to support string-type inputs alongside numeric inputs. The codebase already has foundational support: MathcadPy's `set_string_input()` method exists in worker.py (line 85-88), and `InputConfig.value` accepts `Any` type. However, the frontend UI only provides `NumberInput` components for range generation, and lacks mechanisms for users to explicitly specify input types or provide string values/lists.

The primary challenges are:
1. **UI layer**: Providing a way for users to specify string values (no ranges, just single/list/CSV)
2. **Type detection**: Determining whether CSV column contains strings or numbers
3. **Type preservation**: Ensuring string values remain strings through the entire pipeline (UI → API → Engine)

The standard approach is explicit type selection in the UI (not auto-detection) to prevent ambiguity, with simplified input options for strings (no range generation) and proper type preservation through the API layer.

**Primary recommendation:** Add explicit "Input Type" selector (Number/String) to InputModal, disable range tab for strings, preserve type information in InputConfig through to MathcadPy calls, and handle CSV parsing with pandas' type inference while allowing user override.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| MathcadPy | 0.5 | String input support via `set_string_input()` | Already integrated, handles COM API complexity |
| Mantine | 7.x | React UI components (TextInput, Select, SegmentedControl) | Already in use, provides consistent components |
| TypeScript | 5.x | Type safety for input config | Already in use, prevents type confusion |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| pandas | Latest | CSV type inference | CSV parsing with mixed types (via Python backend) |
| csv (stdlib) | 3.13 | Simple CSV parsing | When pandas is overkill for frontend CSV preview |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Explicit type selector | Auto-detection from value | Auto-detection is ambiguous ("123" could be string or number), explicit is clearer |
| Separate string input modal | Unified modal with type switch | Unified modal reuses existing code, better UX consistency |
| String validation | Accept any text | For Phase 3.3, accept any string (validation can be phase 3.4 if needed) |

**Installation:**
No new dependencies required - all libraries already installed in project.

## Architecture Patterns

### Recommended Project Structure
```
frontend/src/components/
├── InputModal.tsx           # MODIFY: Add type selector, conditional tabs
├── MappingModal.tsx         # No changes needed (already uses InputConfig)
└── ...

src/engine/
├── worker.py                # ALREADY SUPPORTS: set_string_input() exists
├── batch_manager.py         # No changes needed (type-agnostic)
└── protocol.py              # MAYBE ADD: type hint field to InputConfig
```

### Pattern 1: Explicit Type Selection in UI
**What:** User explicitly selects "Number" or "String" before configuring input
**When to use:** All input configuration (batch and workflow)
**Example:**
```typescript
// Add to InputModal.tsx
import { SegmentedControl } from '@mantine/core'

const [inputType, setInputType] = useState<'number' | 'string'>('number')

<SegmentedControl
  value={inputType}
  onChange={setInputType}
  data={[
    { label: 'Number', value: 'number' },
    { label: 'String', value: 'string' }
  ]}
/>

{/* Conditionally render tabs based on type */}
{inputType === 'number' ? (
  <Tabs value={activeTab} onChange={setActiveTab}>
    <Tabs.Tab value="range">Range</Tabs.Tab>
    <Tabs.Tab value="csv">CSV File</Tabs.Tab>
  </Tabs>
) : (
  <Tabs value={activeTab} onChange={setActiveTab}>
    <Tabs.Tab value="single">Single Value</Tabs.Tab>
    <Tabs.Tab value="csv">CSV File</Tabs.Tab>
  </Tabs>
)}
```

### Pattern 2: Type Preservation Through API
**What:** Store type information in InputConfig, use it in worker.py
**When to use:** All input configurations that flow to engine
**Example:**
```python
# In protocol.py (OPTIONAL enhancement)
@dataclass
class InputConfig:
    alias: str
    value: Any
    units: Optional[str] = None
    input_type: Optional[str] = None  # "number" | "string" | None (auto-detect)

# In worker.py set_input() - ALREADY HANDLES THIS
def set_input(self, alias: str, value: Any, units: Optional[str] = None):
    if isinstance(value, str):
        # String path
        error = self.worksheet.set_string_input(alias, value)
    else:
        # Number path
        error = self.worksheet.set_real_input(alias, float(value), units=units_param, ...)
```

**Note:** Current worker.py already uses `isinstance(value, str)` for type detection (line 85), so explicit type field in InputConfig is optional - type information is preserved naturally through Python's duck typing.

### Pattern 3: CSV Type Detection with Pandas
**What:** Use pandas to infer column types when parsing CSV
**When to use:** Backend CSV processing for batch operations
**Example:**
```python
# Backend CSV parsing with type inference
import pandas as pd

def parse_csv_column(file_path: str, column_name: str) -> list:
    """Parse CSV column preserving types"""
    df = pd.read_csv(file_path, dtype=None)  # Infer types
    column_data = df[column_name].tolist()
    return column_data  # Returns typed values (str, int, float, etc.)
```

**Frontend CSV parsing:** Current implementation uses custom `parseCSV` that treats all values as strings. For string inputs, this is correct. For numeric inputs, frontend converts to numbers during range generation.

### Pattern 4: String Input Validation
**What:** Basic validation for string inputs (non-empty, length limits)
**When to use:** Optional - can be deferred to later phase
**Example:**
```typescript
// Optional validation in InputModal
const handleSave = () => {
  if (inputType === 'string') {
    if (typeof value === 'string' && value.trim().length === 0) {
      notifications.show({ message: 'String value cannot be empty', color: 'red' })
      return
    }
  }
  // ... existing save logic
}
```

### Anti-Patterns to Avoid
- **Auto-detecting type from value:** Ambiguous for values like "123", "true", "1.5" - could be intentional strings
- **Converting strings to numbers:** Don't call `Number(value)` on user input unless type is explicitly "number"
- **Assuming numeric range:** Don't show range/step inputs for string type
- **Type coercion in API:** Don't let backend "helpfully" convert types - preserve what user sent

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| CSV type inference | Custom parser with regex/heuristics | pandas `read_csv()` with dtype inference | Handles edge cases (quoted numbers, scientific notation, dates), well-tested |
| Type detection UI | Custom radio buttons with styling | Mantine's SegmentedControl | Built-in accessibility, consistent with app design |
| String validation | Custom regex patterns | TypeScript type guards + trim() | Sufficient for Phase 3.3, complex validation can be later phase |
| Type preservation | Manual type tracking | Python's isinstance() + duck typing | Already working in worker.py line 85-88 |

**Key insight:** The infrastructure already exists. The main work is UI changes (add type selector, conditional tabs) and ensuring frontend doesn't coerce strings to numbers during CSV parsing.

## Common Pitfalls

### Pitfall 1: Unintentional Type Coercion
**What goes wrong:** JavaScript converts "123" to number 123, then MathcadPy receives wrong type
**Why it happens:** NumberInput component coerces values, or developer uses `Number(value)` reflexively
**How to avoid:** When inputType is 'string', use TextInput component and skip any Number() conversions
**Warning signs:** Mathcad receives numeric value when string expected, or set_string_input fails with type error

```typescript
// WRONG - coerces to number
const value = Number(inputValue)  // "123" becomes 123

// RIGHT - preserve type
const value = inputType === 'string' ? String(inputValue) : Number(inputValue)
```

### Pitfall 2: CSV Parsing Type Confusion
**What goes wrong:** CSV column "123,456,789" parsed as strings but user expects numbers, or vice versa
**Why it happens:** Frontend parseCSV treats all values as strings
**How to avoid:** For string inputs, this is correct. For numeric inputs with CSV, ensure frontend/backend convert to numbers
**Warning signs:** Batch processing fails with "set_real_input" type errors on CSV values

### Pitfall 3: Units on String Inputs
**What goes wrong:** User tries to set units on a string input
**Why it happens:** UI shows units dropdown even for string type
**How to avoid:** Hide or disable units selector when inputType === 'string' (strings don't have units)
**Warning signs:** Confusing UX, units field shown but ignored

```typescript
// Hide units for string inputs
{inputType === 'number' && (
  <Select
    label="Units"
    data={UNIT_PRESETS}
    value={selectedUnits}
    onChange={setSelectedUnits}
  />
)}
```

### Pitfall 4: Range Generation for Strings
**What goes wrong:** User confused why "Range" tab doesn't work with string inputs
**Why it happens:** Range (start, end, step) only makes sense for numbers
**How to avoid:** Remove or disable "Range" tab when inputType === 'string'
**Warning signs:** User tries to generate range of strings, gets type errors or confusing behavior

### Pitfall 5: Type Mismatch in Workflow Mappings
**What goes wrong:** Workflow maps string output to numeric input, or vice versa
**Why it happens:** Mapping UI doesn't validate type compatibility
**How to avoid:** This is a Phase 3.3 edge case - defer validation to later phase, or add warning in Phase 3.3
**Warning signs:** Workflow fails with type error during execution

### Pitfall 6: Empty String Handling
**What goes wrong:** User accidentally saves empty string as input value
**Why it happens:** TextInput allows empty submission
**How to avoid:** Validate that string inputs have non-empty trimmed value before save
**Warning signs:** Mathcad fails to set input, or calculation produces unexpected results

## Code Examples

Verified patterns from existing codebase and standard practices:

### InputModal with Type Selection
```typescript
// Source: Adapted from existing InputModal.tsx and Mantine SegmentedControl docs
import { Modal, NumberInput, TextInput, Button, Stack, Group, Tabs, FileInput, Text, Select, SegmentedControl } from '@mantine/core'
import { useState, useEffect } from 'react'
import { generateRange } from '../utils/generators'
import { parseCSV, getHeaders } from '../utils/csv_parser'
import type { InputConfig } from '../services/api'

const UNIT_PRESETS = [/* existing units */]

interface InputModalProps {
  opened: boolean
  onClose: () => void
  alias: string
  onSave: (config: InputConfig) => void
}

export const InputModal = ({ opened, onClose, alias, onSave }: InputModalProps) => {
  // Type selection
  const [inputType, setInputType] = useState<'number' | 'string'>('number')
  const [activeTab, setActiveTab] = useState<string | null>('range')

  // Number inputs
  const [start, setStart] = useState<number | string>(0)
  const [end, setEnd] = useState<number | string>(10)
  const [step, setStep] = useState<number | string>(1)

  // String inputs
  const [stringValue, setStringValue] = useState<string>('')

  // CSV state
  const [csvFile, setCsvFile] = useState<File | null>(null)
  const [csvHeaders, setCsvHeaders] = useState<string[]>([])
  const [selectedHeader, setSelectedHeader] = useState<string | null>(null)
  const [csvData, setCsvData] = useState<any[]>([])
  const [selectedUnits, setSelectedUnits] = useState<string | null>("")

  // When type changes, reset tab
  useEffect(() => {
    if (inputType === 'string') {
      setActiveTab('single')  // String default tab
    } else {
      setActiveTab('range')   // Number default tab
    }
  }, [inputType])

  // Existing CSV logic
  useEffect(() => {
    if (csvFile) {
      getHeaders(csvFile).then(setCsvHeaders).catch(console.error);
      parseCSV(csvFile).then(setCsvData).catch(console.error);
    } else {
      setCsvHeaders([]);
      setCsvData([]);
      setSelectedHeader(null);
    }
  }, [csvFile]);

  const handleSave = () => {
    let value: any = null

    if (inputType === 'number') {
      value = activeTab === 'range'
        ? generateRange(Number(start), Number(end), Number(step))
        : (selectedHeader && csvData.length > 0
          ? csvData.map(row => Number(row[selectedHeader]))  // Convert CSV to numbers
          : null)
    } else {
      // String type
      value = activeTab === 'single'
        ? [stringValue.trim()]  // Single string as array
        : (selectedHeader && csvData.length > 0
          ? csvData.map(row => String(row[selectedHeader]).trim())  // Keep as strings
          : null)
    }

    // Validation
    if (!value || value.length === 0) return
    if (inputType === 'string' && value.some((v: string) => v.length === 0)) {
      alert('String values cannot be empty')
      return
    }

    onSave({
      alias: alias,
      value: value,
      units: inputType === 'number' ? (selectedUnits || undefined) : undefined
    })
  }

  return (
    <Modal opened={opened} onClose={onClose} title={`Configure Alias: ${alias}`} size="md" centered>
      <Stack gap="md" style={{ maxHeight: '80vh', overflowY: 'auto' }}>
        {/* Type selector */}
        <SegmentedControl
          value={inputType}
          onChange={(value) => setInputType(value as 'number' | 'string')}
          data={[
            { label: 'Number', value: 'number' },
            { label: 'String', value: 'string' }
          ]}
          fullWidth
        />

        {/* Conditional tabs based on type */}
        <Tabs value={activeTab} onChange={setActiveTab}>
          <Tabs.List>
            {inputType === 'number' && <Tabs.Tab value="range">Range</Tabs.Tab>}
            {inputType === 'string' && <Tabs.Tab value="single">Single Value</Tabs.Tab>}
            <Tabs.Tab value="csv">CSV File</Tabs.Tab>
          </Tabs.List>

          {/* Range tab (numbers only) */}
          {inputType === 'number' && (
            <Tabs.Panel value="range" pt="md">
              <Stack>
                <Group grow>
                  <NumberInput label="Start" value={start} onChange={setStart} />
                  <NumberInput label="End" value={end} onChange={setEnd} />
                </Group>
                <NumberInput label="Step" value={step} onChange={setStep} />
                <Text size="xs" c="dimmed">
                  Resulting values: {generateRange(Number(start), Number(end), Number(step)).join(', ')}
                </Text>
              </Stack>
            </Tabs.Panel>
          )}

          {/* Single value tab (strings only) */}
          {inputType === 'string' && (
            <Tabs.Panel value="single" pt="md">
              <Stack>
                <TextInput
                  label="String Value"
                  placeholder="Enter string value"
                  value={stringValue}
                  onChange={(e) => setStringValue(e.currentTarget.value)}
                />
                <Text size="xs" c="dimmed">
                  Enter a single string value for this input
                </Text>
              </Stack>
            </Tabs.Panel>
          )}

          {/* CSV tab (both types) */}
          <Tabs.Panel value="csv" pt="md">
            <Stack>
              <FileInput
                label="Upload CSV"
                placeholder="Choose file"
                value={csvFile}
                onChange={setCsvFile}
                accept=".csv"
              />
              {csvHeaders.length > 0 && (
                <Select
                  label="Select Column"
                  placeholder="Choose column"
                  data={csvHeaders}
                  value={selectedHeader}
                  onChange={setSelectedHeader}
                />
              )}
              {selectedHeader && (
                <Text size="xs" c="dimmed">
                  Found {csvData.length} rows. Type: {inputType}
                </Text>
              )}
            </Stack>
          </Tabs.Panel>
        </Tabs>

        {/* Units selector (numbers only) */}
        {inputType === 'number' && (
          <Select
            label="Units"
            placeholder="Select units (optional)"
            data={UNIT_PRESETS}
            value={selectedUnits}
            onChange={setSelectedUnits}
            searchable
            allowDeselect={false}
          />
        )}

        <Group justify="flex-end" mt="md">
          <Button variant="outline" onClick={onClose}>Cancel</Button>
          <Button onClick={handleSave}>Save Configuration</Button>
        </Group>
      </Stack>
    </Modal>
  )
}
```

### Worker Type Detection (Already Implemented)
```python
# Source: Existing worker.py lines 81-106 (already handles strings correctly)
def set_input(self, alias: str, value: Any, units: Optional[str] = None):
    if not self.worksheet:
        raise Exception("No worksheet open")
    try:
        # Type detection via isinstance
        if isinstance(value, str):
            error = self.worksheet.set_string_input(alias, value)
            if error != 0:
                raise Exception(f"set_string_input returned error code {error}")
        else:
            # Numeric path
            is_unitless = units is None or units == "" or units.lower() == "unitless"
            units_param = "" if is_unitless else units
            preserve_units = False

            error = self.worksheet.set_real_input(
                alias, float(value), units=units_param, preserve_worksheet_units=preserve_units
            )
            if error != 0:
                raise Exception(f"set_real_input returned error code {error}")
    except Exception as e:
        raise Exception(f"Failed to set input {alias}: {str(e)}")
```

**Note:** No changes needed to worker.py - it already handles string vs numeric correctly.

### CSV Parsing Preserving Types
```python
# Backend CSV parsing with pandas (for future enhancement)
import pandas as pd

def parse_csv_with_types(file_path: str, column_name: str, force_type: Optional[str] = None):
    """Parse CSV column with type inference or forced type"""
    if force_type == 'string':
        # Force string type
        df = pd.read_csv(file_path, dtype={column_name: str})
    else:
        # Infer types automatically
        df = pd.read_csv(file_path)

    return df[column_name].tolist()
```

**Note:** For Phase 3.3, frontend CSV parsing is sufficient. Backend pandas parsing can be enhancement.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Numeric inputs only | Numeric + string inputs | Phase 3.3 (Jan 2026) | Enables text-based parameters (material names, file paths, labels) |
| Auto-detect from value | Explicit type selector | Modern UX practice (2024+) | Removes ambiguity, clearer user intent |
| NumberInput for everything | NumberInput for numbers, TextInput for strings | Component best practices | Proper validation, better UX |
| CSV as strings | CSV with type inference | Pandas default behavior | Handles mixed-type CSVs correctly |

**Deprecated/outdated:**
- Auto-detecting type from string content: Causes ambiguity with values like "123" or "true"
- Single input component for all types: Modern practice uses type-specific components
- Type coercion in API layer: Backend should preserve frontend's type decisions

## Open Questions

Things that couldn't be fully resolved:

1. **Should InputConfig have explicit type field?**
   - What we know: Worker.py already uses isinstance() for type detection
   - What's unclear: Whether explicit type field aids debugging or is redundant
   - Recommendation: Start without explicit type field (YAGNI), add if debugging shows it's needed

2. **CSV type inference - frontend or backend?**
   - What we know: Frontend parseCSV treats all as strings, backend could use pandas
   - What's unclear: Where type conversion should happen for CSV numeric columns
   - Recommendation: Frontend handles conversion (map to Number()) when inputType='number', keeps simple

3. **String validation requirements**
   - What we know: Empty strings should be prevented
   - What's unclear: Other validation rules (length, special characters, regex patterns)
   - Recommendation: Basic validation (non-empty) in Phase 3.3, defer complex validation to future phase

4. **Type mismatch in workflow mappings**
   - What we know: Workflows map outputs to inputs across files
   - What's unclear: Should Phase 3.3 validate type compatibility in mappings?
   - Recommendation: Defer to later phase - allow any mapping, let Mathcad/worker fail if incompatible

5. **List of strings UI**
   - What we know: Numbers can use range generation, strings cannot
   - What's unclear: Best UI for entering multiple string values (comma-separated? line-separated? CSV only?)
   - Recommendation: Phase 3.3 uses "single value" + CSV for strings. Future phase could add "list" tab with textarea for multiple values.

## Sources

### Primary (HIGH confidence)
- Existing worker.py implementation - Lines 81-106 demonstrate isinstance-based type detection
  - Location: D:\Mathcad_exp\src\engine\worker.py
  - Verified: January 27, 2026
- MathcadPy documentation - set_string_input() and set_real_input() methods
  - Source: Phase 2.1 research document (verified against MathcadPy 0.5)
  - GitHub: https://github.com/MattWoodhead/MathcadPy
  - Verified: January 27, 2026
- Mantine UI documentation - SegmentedControl, TextInput, NumberInput components
  - URL: https://mantine.dev/core/segmented-control/
  - URL: https://mantine.dev/core/number-input/
  - URL: https://mantine.dev/core/text-input/
  - Verified: January 27, 2026

### Secondary (MEDIUM confidence)
- React input type handling patterns
  - Multiple sources discussing type="number" pitfalls and workarounds
  - Source: Web search results from "TypeScript React input component string number type switching 2026"
  - Key insight: Native type="number" returns string, requires conversion
- pandas CSV parsing documentation
  - URL: https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html
  - Key feature: dtype parameter for type inference control
  - Verified: January 27, 2026

### Tertiary (LOW confidence)
- Auto-detection best practices - Web search showed mixed opinions, explicit type selection preferred in modern UX

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use, no new dependencies
- Architecture: HIGH - Based on existing working patterns in codebase
- Pitfalls: HIGH - Identified from common React/TypeScript type coercion issues

**Research date:** January 27, 2026
**Valid until:** February 26, 2026 (30 days - stable domain, UI patterns well-established)
