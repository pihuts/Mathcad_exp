# Phase 3.4: Multi-Value String Inputs - Research

**Researched:** January 28, 2026
**Domain:** Multi-value string input UI/UX patterns
**Confidence:** HIGH

## Summary

Research investigated extending Phase 3.3's single-value string inputs to support multiple string values, achieving feature parity with numeric Range/List functionality. The codebase already handles string arrays correctly through the batch pipeline's cartesian product logic (generateCartesian in generators.ts works type-agnostically). The backend worker.py processes string values via isinstance detection, and the InputConfig.value field accepts any array type.

The implementation requires three main components:
1. **List input UI**: Add textarea-based multi-line entry for discrete string values (one per line)
2. **Value deduplication**: Silently remove duplicate strings to prevent redundant iterations
3. **Batch preview enhancements**: Display string values alongside numeric ranges in iteration preview

Current architecture already supports multi-value strings in CSV mode - Phase 3.3 implemented CSV column upload with string preservation (line 89 in InputModal.tsx: `csvData.map(row => String(row[selectedHeader]).trim())`). The missing piece is manual entry UI for users who want to type multiple values without creating CSV files.

**Primary recommendation:** Add "List" tab to string input modal with Mantine Textarea (autosize), implement silent deduplication via Set before save, enhance batch preview to show string value counts, and add optional tooltip breakdown showing contribution of each input to total iteration count.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Mantine Textarea | 7.x | Multi-line text input with autosize | Already integrated, built-in autosize via react-textarea-autosize |
| React Set | ES6+ | Array deduplication | Native JavaScript, zero dependencies, O(n) performance |
| Existing generators.ts | Current | Cartesian product logic | Already type-agnostic, handles string arrays correctly |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Mantine Tooltip | 7.x | Iteration count breakdown on hover | Optional enhancement for batch preview |
| Mantine Badge | 7.x | Type indicators for CSV columns | Optional visual enhancement |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Line-separated textarea | Tag/Chip input component | Textarea is simpler, no extra dependencies, better for bulk paste |
| Auto-expand textarea | Fixed-height textarea | Auto-expand better UX, handles 2-20 values gracefully |
| Silent deduplication | Warn user about duplicates | Silent is less friction, duplicates are harmless intent (not error) |
| Tooltip breakdown | Inline formula text | Tooltip is cleaner, doesn't clutter UI permanently |

**Installation:**
No new dependencies required - all libraries already in project.

## Architecture Patterns

### Recommended Project Structure
```
frontend/src/components/
├── InputModal.tsx           # MODIFY: Add List tab for strings, deduplication logic
└── ...

frontend/src/utils/
├── generators.ts            # NO CHANGES: Already handles string arrays
└── ...

frontend/src/
└── App.tsx                  # OPTIONAL: Add iteration breakdown tooltip
```

### Pattern 1: Multi-Line String Entry with Textarea
**What:** Textarea with autosize for entering multiple string values (one per line)
**When to use:** String input type, List tab
**Example:**
```typescript
// Source: Mantine Textarea documentation - https://mantine.dev/core/textarea/
import { Textarea } from '@mantine/core'

// In InputModal.tsx - add List tab for string type
const [listValues, setListValues] = useState<string>('')

// List tab panel (for string type)
<Tabs.Panel value="list" pt="md">
  <Stack>
    <Textarea
      label="String Values"
      placeholder="Enter one value per line&#10;Material A&#10;Material B&#10;Material C"
      value={listValues}
      onChange={(e) => setListValues(e.currentTarget.value)}
      autosize
      minRows={3}
      maxRows={10}
    />
    <Text size="xs" c="dimmed">
      Enter one string value per line. Duplicates will be removed automatically.
    </Text>
  </Stack>
</Tabs.Panel>
```

### Pattern 2: Silent Deduplication with Set
**What:** Remove duplicate strings using ES6 Set before saving configuration
**When to use:** All multi-value string inputs (List and CSV modes)
**Example:**
```typescript
// Source: Modern JavaScript best practices - https://medium.com/@hxu0407/get-800x-faster-array-deduplication-in-javascript-just-use-set-025b5a28d4d1
const handleSave = () => {
  let value: any = null;

  if (inputType === 'string') {
    if (activeTab === 'list') {
      // Split by newline, trim whitespace, remove empty lines
      const rawValues = listValues
        .split('\n')
        .map(v => v.trim())
        .filter(v => v.length > 0);

      // Deduplicate using Set (800x faster than filter/indexOf)
      value = [...new Set(rawValues)];

      if (value.length === 0) return; // Don't save empty list
    } else if (activeTab === 'single') {
      // Single value - wrap in array
      const trimmed = stringValue.trim();
      if (trimmed === '') return;
      value = [trimmed];
    } else if (activeTab === 'csv' && selectedHeader && csvData.length > 0) {
      // CSV - extract column, deduplicate
      const rawValues = csvData
        .map(row => String(row[selectedHeader]).trim())
        .filter(v => v.length > 0);

      value = [...new Set(rawValues)];
    }
  }
  // ... numeric handling unchanged
}
```

### Pattern 3: Iteration Count Breakdown Tooltip
**What:** Show how each input contributes to total iteration count on hover
**When to use:** Batch preview when multiple inputs configured
**Example:**
```typescript
// Source: Mantine Tooltip - https://mantine.dev/core/tooltip/
import { Tooltip } from '@mantine/core'

// In App.tsx - calculate breakdown
const iterationBreakdown = useMemo(() => {
  const keys = Object.keys(aliasConfigs);
  if (keys.length === 0) return '';

  const parts = keys.map(key => `${key}: ${aliasConfigs[key].length} values`);
  const formula = keys.map(key => aliasConfigs[key].length).join(' × ');

  return `${parts.join('\n')}\n\nFormula: ${formula} = ${iterationCount}`;
}, [aliasConfigs, iterationCount]);

// Render with tooltip
<Tooltip label={iterationBreakdown} multiline withArrow>
  <Text size="sm" fw={500} style={{ cursor: 'help' }}>
    Total Iterations: {iterationCount} ⓘ
  </Text>
</Tooltip>
```

### Pattern 4: Context-Sensitive Tab Visibility
**What:** Show List tab only for string type, hide for numeric
**When to use:** InputModal tab configuration
**Example:**
```typescript
// String type tabs: Single Value, List, CSV
// Number type tabs: Range, CSV (existing)

<Tabs value={activeTab} onChange={setActiveTab}>
  <Tabs.List>
    {inputType === 'number' && <Tabs.Tab value="range">Range</Tabs.Tab>}
    {inputType === 'string' && <Tabs.Tab value="single">Single Value</Tabs.Tab>}
    {inputType === 'string' && <Tabs.Tab value="list">List</Tabs.Tab>}
    <Tabs.Tab value="csv">CSV File</Tabs.Tab>
  </Tabs.List>
  {/* ... panels ... */}
</Tabs>

// Update useEffect to default to 'list' instead of 'single' for better discoverability
useEffect(() => {
  if (inputType === 'string') {
    setActiveTab('list');  // Default to List tab (multi-value is primary use case)
  } else if (inputType === 'number') {
    setActiveTab('range');
  }
}, [inputType]);
```

### Anti-Patterns to Avoid
- **Tag/Chip input component:** Overkill for this use case, adds dependency, worse for bulk paste
- **Comma-separated in TextInput:** Ambiguous for strings that contain commas (e.g., "Smith, John")
- **Warning modal for duplicates:** Creates friction, duplicates are benign (user likely copy-pasted from source with repeats)
- **Manual resizing textarea:** Poor UX, autosize is standard practice in 2026
- **Showing duplicate count:** Unnecessary detail, silent deduplication is cleaner

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Array deduplication | filter((v,i,a) => a.indexOf(v)===i) | [...new Set(array)] | 800x faster, cleaner syntax, handles all edge cases |
| Textarea auto-resize | Custom scrollHeight calculation | Mantine Textarea with autosize prop | Handles resize events, window resizing, pre-filled values automatically |
| Multi-line placeholder | \\n in string | Actual newlines in placeholder attribute | HTML supports literal newlines, better readability |
| Line splitting | split('\\n').map(trim).filter | split + map + filter chain | Readable, idiomatic JavaScript, handles edge cases |

**Key insight:** The infrastructure for multi-value strings already exists (cartesian product, CSV parsing, backend handling). This phase is purely additive UI work - add List tab, wire up deduplication, done.

## Common Pitfalls

### Pitfall 1: Not Handling Empty Lines
**What goes wrong:** User presses Enter multiple times, gets empty strings in array
**Why it happens:** split('\\n') includes empty strings between consecutive newlines
**How to avoid:** Filter out empty strings after trim: `.filter(v => v.length > 0)`
**Warning signs:** Batch fails with "String value cannot be empty" or MathcadPy errors

```typescript
// WRONG - includes empty strings
const values = listValues.split('\n').map(v => v.trim())

// RIGHT - filters empty lines
const values = listValues.split('\n').map(v => v.trim()).filter(v => v.length > 0)
```

### Pitfall 2: Forgetting Deduplication on CSV
**What goes wrong:** CSV contains duplicate values, creates redundant iterations
**Why it happens:** Deduplication added to List tab but CSV path unchanged
**How to avoid:** Apply Set deduplication to ALL string array sources (List, CSV, future)
**Warning signs:** Iteration count higher than expected, duplicate rows in batch results

### Pitfall 3: Preserving Whitespace Around Values
**What goes wrong:** "Material A" and "Material A " treated as different strings
**Why it happens:** Not trimming values before deduplication
**How to avoid:** Always trim before creating Set: `.map(v => v.trim())`
**Warning signs:** Duplicate-looking values in batch preview, unexpected iteration count

### Pitfall 4: Type Coercion in Cartesian Product
**What goes wrong:** String "123" gets converted to number 123 in generateCartesian
**Why it happens:** Misunderstanding how generators.ts works
**How to avoid:** Verify generators.ts is type-agnostic (it is - just spreads values)
**Warning signs:** Worker.py receives numbers instead of strings, set_string_input fails

**Note:** This is NOT a real pitfall in current codebase - generators.ts is already correct. Including for completeness.

### Pitfall 5: Not Resetting activeTab When Switching Types
**What goes wrong:** User switches from Number to String, stuck on Range tab (doesn't exist for String)
**Why it happens:** Missing useEffect to sync activeTab with inputType changes
**How to avoid:** Existing useEffect in Phase 3.3 already handles this - just extend List tab logic
**Warning signs:** Blank modal content, no visible tab selected

**Note:** Phase 3.3 already solved this. Including for planner awareness.

### Pitfall 6: Batch Preview Truncation
**What goes wrong:** Long string values make batch preview unreadable
**Why it happens:** Table cells don't truncate by default
**How to avoid:** This is Claude's Discretion - could truncate with ellipsis, wrap text, or horizontal scroll
**Warning signs:** Horizontal scrollbar extends far right, poor UX for long material names

**Recommendation:** Defer to planner - could use Mantine Text with truncate prop or add maxWidth to table cells.

## Code Examples

Verified patterns from existing codebase and standard practices:

### Complete InputModal List Tab Implementation
```typescript
// Source: Adapted from Phase 3.3 InputModal.tsx + Mantine Textarea docs
import { Textarea } from '@mantine/core'

// Add state for list values
const [listValues, setListValues] = useState<string>('')

// Add List tab to tab list (only when inputType === 'string')
<Tabs.List>
  {inputType === 'number' && <Tabs.Tab value="range">Range</Tabs.Tab>}
  {inputType === 'string' && <Tabs.Tab value="single">Single Value</Tabs.Tab>}
  {inputType === 'string' && <Tabs.Tab value="list">List</Tabs.Tab>}
  <Tabs.Tab value="csv">CSV File</Tabs.Tab>
</Tabs.List>

// Add List tab panel
{inputType === 'string' && (
  <Tabs.Panel value="list" pt="md">
    <Stack>
      <Textarea
        label="String Values (one per line)"
        placeholder="Material A&#10;Material B&#10;Material C"
        value={listValues}
        onChange={(e) => setListValues(e.currentTarget.value)}
        autosize
        minRows={3}
        maxRows={10}
        description="Enter one value per line. Empty lines and duplicates will be removed."
      />
      <Text size="xs" c="dimmed">
        Preview: {listValues.split('\n').map(v => v.trim()).filter(v => v.length > 0).length} unique values
      </Text>
    </Stack>
  </Tabs.Panel>
)}

// Update handleSave to process List tab
const handleSave = () => {
  let value: any = null;

  if (inputType === 'number') {
    // Existing numeric logic unchanged
    if (activeTab === 'range') {
      value = generateRange(Number(start), Number(end), Number(step));
    } else if (activeTab === 'csv' && selectedHeader && csvData.length > 0) {
      value = csvData.map(row => Number(row[selectedHeader]));
    }
  } else if (inputType === 'string') {
    if (activeTab === 'single') {
      const trimmed = stringValue.trim();
      if (trimmed === '') return;
      value = [trimmed];
    } else if (activeTab === 'list') {
      // NEW: Process list values
      const rawValues = listValues
        .split('\n')
        .map(v => v.trim())
        .filter(v => v.length > 0);

      // Deduplicate
      value = [...new Set(rawValues)];

      if (value.length === 0) return; // Don't save empty list
    } else if (activeTab === 'csv' && selectedHeader && csvData.length > 0) {
      // ENHANCED: Add deduplication to CSV path
      const rawValues = csvData
        .map(row => String(row[selectedHeader]).trim())
        .filter(v => v.length > 0);

      value = [...new Set(rawValues)];

      if (value.length === 0) return;
    }
  }

  if (value !== null) {
    onSave({
      alias: alias,
      value: value,
      units: inputType === 'number' ? (selectedUnits || undefined) : undefined
    });
  }
}

// Update default tab when type changes
useEffect(() => {
  if (inputType === 'string') {
    setActiveTab('list');  // Default to List (multi-value is primary use case)
  } else if (inputType === 'number') {
    setActiveTab('range');
  }
}, [inputType]);
```

### Optional: Iteration Count Breakdown Tooltip
```typescript
// Source: Mantine Tooltip docs + App.tsx existing iteration count logic
import { Tooltip, Text } from '@mantine/core'

// In App.tsx - add breakdown calculation
const iterationBreakdown = useMemo(() => {
  const keys = Object.keys(aliasConfigs);
  if (keys.length === 0) return null;

  const breakdown = keys.map(key => {
    const count = aliasConfigs[key].length;
    const type = aliasTypes[key] || 'unknown';
    return `${key} (${type}): ${count} value${count === 1 ? '' : 's'}`;
  });

  const formula = keys.map(key => aliasConfigs[key].length).join(' × ');

  return (
    <>
      {breakdown.map((line, i) => (
        <div key={i}>{line}</div>
      ))}
      <div style={{ marginTop: 8, borderTop: '1px solid #444', paddingTop: 8 }}>
        Formula: {formula} = {iterationCount}
      </div>
    </>
  );
}, [aliasConfigs, aliasTypes, iterationCount]);

// Replace existing iteration count display
{iterationBreakdown ? (
  <Tooltip label={iterationBreakdown} multiline withArrow position="bottom">
    <Text size="sm" fw={500} style={{ cursor: 'help', borderBottom: '1px dotted' }}>
      Total Iterations: {iterationCount} ⓘ
    </Text>
  </Tooltip>
) : (
  <Text size="sm" fw={500}>
    Total Iterations: {iterationCount}
  </Text>
)}
```

### Optional: CSV Column Type Indicator
```typescript
// Source: Mantine Badge component + existing CSV mapping
import { Badge } from '@mantine/core'

// In MappingModal or InputModal CSV preview
{csvHeaders.length > 0 && (
  <Stack>
    {csvHeaders.map(header => {
      // Detect type from first non-null value
      const firstValue = csvData.find(row => row[header] != null)?.[header];
      const isString = typeof firstValue === 'string' && isNaN(Number(firstValue));

      return (
        <Group key={header}>
          <Text>{header}</Text>
          <Badge size="xs" color={isString ? 'blue' : 'green'}>
            {isString ? 'String' : 'Number'}
          </Badge>
        </Group>
      );
    })}
  </Stack>
)}
```

**Note:** Type indicator is optional enhancement - defer to planner based on time budget.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| CSV-only for multi-value strings | CSV + manual List entry | Phase 3.4 (Jan 2026) | Reduces friction for small value sets (2-5 items) |
| No deduplication | Silent Set-based deduplication | Modern JS best practice (ES6+) | Prevents redundant iterations, cleaner UX |
| Fixed-height textarea | Autosize textarea with minRows/maxRows | Mantine 7.x default | Adapts to content, better for 2-20 values |
| Inline iteration formula | Tooltip breakdown | Modern UX pattern | Cleaner UI, detail on demand |
| Manual comma separation | Line-separated values | Industry standard (2024+) | Handles commas in values, better paste experience |

**Deprecated/outdated:**
- Tag/chip input components for bulk entry: Modern practice favors textarea for 5+ items
- Comma-separated values in single-line input: Breaks for values containing commas
- Warning users about duplicates: Modern UX silently deduplicates (duplicates are benign, not errors)

## Open Questions

Things that couldn't be fully resolved:

1. **Default tab for string type - Single or List?**
   - What we know: User context determines which is more common (single material name vs. list of configurations)
   - What's unclear: Without user research, don't know primary use case ratio
   - Recommendation: Default to List tab - multi-value is the phase goal, and single-value users can click once

2. **Should batch preview truncate long string values?**
   - What we know: Material names can be short ("Steel") or long ("ASTM A36 Hot-Rolled Carbon Steel Plate")
   - What's unclear: Best UX for displaying mixed-length strings in table
   - Recommendation: Claude's Discretion - planner can choose truncate with ellipsis + title attribute, or wrap text

3. **CSV type auto-detection accuracy**
   - What we know: Current CSV parser treats all as strings, relies on user's inputType selection
   - What's unclear: Should CSV auto-detect types and show badges/indicators?
   - Recommendation: Optional enhancement - nice to have but not critical, defer to planner based on complexity

4. **Empty cell handling in CSV string columns**
   - What we know: Current implementation filters empty strings with `.filter(v => v.length > 0)`
   - What's unclear: Should empty CSV cells skip row, pass empty string, or warn user?
   - Recommendation: Skip empty cells (current behavior is correct) - passing empty strings would fail MathcadPy validation

5. **Line ending handling (CRLF vs LF)**
   - What we know: Windows uses \\r\\n, Unix uses \\n
   - What's unclear: Does split('\\n') handle \\r\\n correctly?
   - Recommendation: Use split(/\r?\n/) to handle both, or rely on trim() to remove \\r (which it does)

## Sources

### Primary (HIGH confidence)
- Mantine Textarea documentation
  - URL: https://mantine.dev/core/textarea/
  - Features verified: autosize, minRows, maxRows, onChange pattern
  - Verified: January 28, 2026
- Existing codebase - Phase 3.3 InputModal implementation
  - Location: D:\Mathcad_exp\frontend\src\components\InputModal.tsx
  - Lines 139-153: String single-value implementation (provides template for List tab)
  - Verified: January 28, 2026
- Existing generators.ts - Cartesian product
  - Location: D:\Mathcad_exp\frontend\src\utils\generators.ts
  - Lines 27-46: Type-agnostic implementation already handles string arrays
  - Verified: January 28, 2026
- ES6 Set deduplication performance analysis
  - Article: "Get 800x Faster Array Deduplication in JavaScript — Just Use Set"
  - URL: https://medium.com/@hxu0407/get-800x-faster-array-deduplication-in-javascript-just-use-set-025b5a28d4d1
  - Key finding: Set-based deduplication is O(n) vs O(n²) for filter/indexOf
  - Verified: January 28, 2026

### Secondary (MEDIUM confidence)
- UX patterns for multi-value text input
  - Tag Input Pattern guide
  - URL: https://uxpatterns.dev/patterns/forms/tag-input
  - Key insight: Tag/chip input for small sets, textarea for bulk entry (5+ items)
  - Verified: January 28, 2026
- React textarea autosize best practices
  - Multiple sources discussing react-textarea-autosize package
  - Key finding: Mantine's built-in autosize leverages this package (zero config needed)
  - Source: https://www.npmjs.com/package/react-textarea-autosize
  - Verified: January 28, 2026
- Array deduplication techniques
  - Multiple JavaScript community sources
  - URL: https://codewithhugo.com/es6-dedupe-set/
  - Consensus: [...new Set(array)] is modern standard
  - Verified: January 28, 2026

### Tertiary (LOW confidence)
- Batch preview tooltip patterns - web search showed mixed implementations across platforms
  - No single authoritative source, Mantine Tooltip docs provide implementation guide
- CSV empty cell handling - community best practices vary by domain
  - Engineering calculation context suggests skipping empty cells (current behavior)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in use (Mantine 7.x, ES6 Set)
- Architecture: HIGH - Based on existing Phase 3.3 patterns, minimal new code
- Pitfalls: HIGH - Common JavaScript string handling edge cases well-documented

**Research date:** January 28, 2026
**Valid until:** February 27, 2026 (30 days - stable domain, established patterns)

**Key dependencies:**
- Phase 3.3 completion: String input infrastructure must be working
- No external library additions required
- No backend changes needed (worker.py already handles string arrays)

**Complexity assessment:** LOW
- UI: Add one tab (List) to existing modal
- Logic: Standard JavaScript (split, trim, filter, Set)
- Testing: Verify deduplication, empty line handling, cartesian product
