# Phase 3.1: Replace text inputs with browse buttons - Research

**Researched:** 2026-01-26
**Domain:** Local file browsing in web-based desktop applications
**Confidence:** MEDIUM-HIGH

## Summary

This phase aims to replace text-based file path inputs with browse buttons throughout the application. The challenge is that the app runs as a web interface (React + Mantine UI) serving from a local FastAPI backend, but needs to access the local Windows filesystem with native file dialogs. The application is designed for eventual PyInstaller packaging into a standalone .exe for non-technical users.

There are three viable approaches:

1. **Browser-native HTML file picker** (RECOMMENDED) - Simple, works immediately, no dependencies
2. **Python backend file dialog via tkinter** - Backend triggers native file dialog, returns path
3. **Electron/Tauri desktop wrapper** - Full desktop integration (future packaging option)

For this phase, **Approach 1 (Browser-native)** is recommended because it requires minimal changes and works with the existing tech stack. The application already uses Mantine UI's FileInput component for CSV uploads, so extending this pattern to .mcdx file selection is straightforward. Since the app will eventually be packaged as a desktop executable (Phase 5), the browser security restrictions on file paths are not a concern in the local context.

**Primary recommendation:** Use Mantine's FileButton component with HTML5 file input API to trigger native file picker dialogs. Accept File objects on the frontend and send full file paths to the backend.

## Standard Stack

The established libraries/tools for this domain:

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @mantine/core | 8.3.13 | UI components including FileButton/FileInput | Already in use, provides styled file picker components |
| HTML5 File API | Native | Browser file selection via `<input type="file">` | Universal browser support, triggers native OS file dialogs |
| React hooks (useState) | 19.2.0 | Manage file selection state | Already in use throughout the app |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| tkinter.filedialog | Built-in Python | Backend-initiated native file dialogs | If backend needs to trigger browse dialog |
| PyQt5/PySide6 | Latest | Alternative GUI library for file dialogs | If more control needed over dialog appearance |
| File System Access API (showOpenFilePicker) | Native browser | Modern file picker API | For advanced use cases (currently Chromium-only) |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| HTML file input | Electron/Tauri desktop wrapper | More native integration but adds 100MB+ to bundle and requires full architecture change |
| HTML file input | tkinter backend dialog | More complex (threading issues, async coordination) but provides consistent cross-browser experience |
| File paths only | Full File API with FileReader | Could support drag-and-drop and preview, but unnecessary for simple path selection |

**Installation:**
```bash
# Already installed - no new dependencies needed for Approach 1
npm list @mantine/core  # Should show 8.3.13
```

For backend approach (tkinter), no installation needed - tkinter is built into Python 3.x.

## Architecture Patterns

### Recommended Project Structure
```
frontend/src/
├── components/
│   ├── InputModal.tsx       # Already uses FileInput for CSV
│   ├── MappingModal.tsx     # No file input currently
│   └── WorkflowBuilder.tsx  # Currently uses TextInput for file paths (LINE 128)
└── utils/
    └── fileHandlers.ts      # (Optional) Centralized file handling utilities
```

### Pattern 1: Browser-Native File Picker with Mantine FileButton

**What:** Replace TextInput components with Mantine FileButton that triggers native file picker
**When to use:** All file path inputs in the application
**Example:**
```typescript
// Source: https://mantine.dev/core/file-button/
import { FileButton, Button, Group, Text } from '@mantine/core';
import { useState } from 'react';

function FilePicker() {
  const [file, setFile] = useState<File | null>(null);

  return (
    <Group>
      <FileButton
        onChange={setFile}
        accept=".mcdx"
      >
        {(props) => <Button {...props}>Browse for .mcdx file</Button>}
      </FileButton>
      {file && (
        <Text size="sm" truncate>
          {file.name}
        </Text>
      )}
    </Group>
  );
}
```

**Key points:**
- FileButton uses render prop pattern (function as children)
- `accept` prop filters to .mcdx files only
- File object contains name, size, type, and full path (in local desktop context)
- Can reset using `resetRef` pattern when user clears selection

### Pattern 2: Extracting Full Path from File Object

**What:** When the app runs as a local desktop app (PyInstaller), File objects expose full paths
**When to use:** Need to send absolute file path to backend API
**Example:**
```typescript
// In local desktop context, file.path or file.webkitRelativePath may be available
// For PyInstaller-packaged app, browser restrictions don't apply
const handleFileChange = (file: File | null) => {
  if (!file) return;

  // In local context, one of these will work:
  const fullPath = (file as any).path || file.name;

  // Send to backend
  updateFilePath(index, fullPath);
};
```

**Note:** In standard web browsers, full paths are restricted for security. However, when the app runs locally via PyInstaller + webview, these restrictions may not apply, or you can use alternative methods to get the path.

### Pattern 3: Backend-Triggered File Dialog (Alternative Approach)

**What:** FastAPI endpoint triggers Python tkinter file dialog, returns selected path
**When to use:** If browser path restrictions prove problematic
**Example:**
```python
# Source: https://pythontutorial.net/tkinter/tkinter-open-file-dialog/
from fastapi import APIRouter
from tkinter import Tk, filedialog
import threading

router = APIRouter()

def _select_file():
    """Run in separate thread to avoid blocking"""
    root = Tk()
    root.withdraw()  # Hide root window
    root.attributes('-topmost', True)  # Bring dialog to front

    file_path = filedialog.askopenfilename(
        title="Select Mathcad file",
        filetypes=[("Mathcad Prime", "*.mcdx"), ("All files", "*.*")]
    )
    root.destroy()
    return file_path

@router.post("/files/browse")
async def browse_file():
    """Trigger native file dialog and return selected path"""
    # Must run in thread to avoid blocking FastAPI
    result = await asyncio.to_thread(_select_file)
    return {"file_path": result}
```

**Frontend usage:**
```typescript
const handleBrowse = async () => {
  const response = await fetch('http://localhost:8000/api/v1/files/browse', {
    method: 'POST'
  });
  const data = await response.json();
  if (data.file_path) {
    setFilePath(data.file_path);
  }
};
```

### Anti-Patterns to Avoid

- **Using text input with manual path entry as primary method:** Error-prone, bad UX, defeats purpose of this phase
- **Assuming File.path always exists in browser:** This property is non-standard and only available in some contexts (Electron, local file:// URLs)
- **Synchronous tkinter calls in FastAPI:** tkinter is not thread-safe; must use asyncio.to_thread or run in separate thread
- **Not filtering file types:** Always set accept=".mcdx" to prevent users from selecting incompatible files
- **Blocking the event loop:** File dialogs must not block async web server operation

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Styled file input button | Custom div + hidden input + complex event handling | Mantine FileButton | Handles accessibility, keyboard navigation, focus states, reset logic automatically |
| File type filtering | Manual regex validation after selection | accept prop on file input | Native OS-level filtering in file dialog |
| File path display with overflow | Custom text truncation logic | Mantine Text component with truncate prop | Handles ellipsis, tooltips, responsiveness |
| Thread-safe tkinter | Custom threading + locks | asyncio.to_thread() or threadsafe-tkinter library | Tkinter is notoriously not thread-safe; tested solutions exist |
| Cross-platform file dialogs | OS-specific implementations | tkinter.filedialog (Python) or FileButton (browser) | Abstracts platform differences automatically |

**Key insight:** File handling in web apps has many edge cases (accessibility, keyboard nav, ARIA labels, file size limits, MIME type validation). Mature libraries like Mantine have already solved these. For backend dialogs, tkinter's thread safety issues are well-known and have established workarounds.

## Common Pitfalls

### Pitfall 1: Browser Security Restrictions on File Paths

**What goes wrong:** Developer expects to read full file system path from File object in browser, but only gets fake path like "C:\fakepath\file.mcdx" for security reasons.

**Why it happens:** Browsers intentionally hide real file paths to prevent malicious sites from fingerprinting user's filesystem structure.

**How to avoid:**
- For PyInstaller-packaged app: Use webview that exposes real paths, or use Pattern 3 (backend dialog)
- For development: Test with full path access or mock paths
- For web-only version: Not possible; must accept File objects only

**Warning signs:**
- File path contains "fakepath"
- Backend errors about file not found
- Path is just filename without directory

**Solution:** Either use backend-triggered dialogs (Pattern 3) or accept that in desktop-packaged version, the webview will provide real paths.

### Pitfall 2: Tkinter Thread Safety in FastAPI

**What goes wrong:** Calling tkinter.filedialog.askopenfilename() directly in FastAPI endpoint causes the entire server to freeze or crash.

**Why it happens:** Tkinter requires GUI event loop to run on main thread, but FastAPI runs async on different thread pool. Tkinter is not thread-safe by default.

**How to avoid:**
- Use asyncio.to_thread() to run tkinter in separate thread
- Ensure tkinter root window is created fresh for each dialog
- Always call root.destroy() after dialog closes
- Consider using mttkinter wrapper if multiple threads need tkinter access

**Warning signs:**
- Server stops responding during file dialog
- "RuntimeError: main thread is not in main loop" errors
- File dialog appears but server crashes on selection

### Pitfall 3: Not Handling File Selection Cancellation

**What goes wrong:** User clicks "Browse" but then cancels the dialog. App shows error or enters invalid state.

**Why it happens:** File picker returns null/empty when cancelled, but code doesn't check for this.

**How to avoid:**
```typescript
const handleFileChange = (file: File | null) => {
  if (!file) {
    // User cancelled or no file selected
    console.log('No file selected');
    return;
  }
  // Proceed with valid file
  processFile(file);
};
```

**Warning signs:**
- Blank file paths sent to backend
- TypeError: Cannot read property 'name' of null
- Empty strings in file path fields after cancel

### Pitfall 4: File Extension Case Sensitivity

**What goes wrong:** User selects "FILE.MCDX" (uppercase) but accept=".mcdx" filter doesn't show it.

**Why it happens:** On Windows, file extensions are case-insensitive, but HTML accept attribute is case-sensitive in some browsers.

**How to avoid:**
- Use multiple accept values: accept=".mcdx,.MCDX"
- Or validate on backend and provide helpful error message
- Or use accept="application/octet-stream" and validate programmatically

**Warning signs:**
- Users report "can't see my files" on Windows
- Files with uppercase extensions not selectable

### Pitfall 5: Missing Reset Functionality

**What goes wrong:** User selects a file, then wants to select a different file, but clicking FileButton again doesn't trigger dialog (stale value on hidden input).

**Why it happens:** HTML file input elements cannot be "controlled" in React - they maintain their own state.

**How to avoid:** Use Mantine FileButton's resetRef pattern:
```typescript
const [file, setFile] = useState<File | null>(null);
const resetRef = useRef<() => void>(null);

const clearFile = () => {
  setFile(null);
  resetRef.current?.();  // Resets the hidden input
};

<FileButton resetRef={resetRef} onChange={setFile} accept=".mcdx">
  {(props) => <Button {...props}>Browse</Button>}
</FileButton>
```

**Warning signs:**
- Can't re-select same file twice
- Hidden input shows old filename
- onChange doesn't fire on second click

## Code Examples

Verified patterns from official sources:

### Example 1: Replace WorkflowBuilder TextInput with FileButton

**Current code (WorkflowBuilder.tsx, line 128-133):**
```typescript
<TextInput
  size="xs"
  placeholder="C:\\path\\to\\file.mcdx"
  value={file.file_path}
  onChange={(e) => handleUpdateFilePath(index, e.currentTarget.value)}
  style={{ flex: 1 }}
/>
```

**Proposed change:**
```typescript
// Source: Mantine docs + project context
import { FileButton, Button, Group, Text, ActionIcon } from '@mantine/core';
import { IconFile, IconX } from '@tabler/icons-react';

<Group gap="xs" style={{ flex: 1 }}>
  <FileButton
    onChange={(selectedFile) => {
      if (selectedFile) {
        // In desktop context, extract full path
        const fullPath = (selectedFile as any).path || selectedFile.name;
        handleUpdateFilePath(index, fullPath);
      }
    }}
    accept=".mcdx,.MCDX"
  >
    {(props) => (
      <Button {...props} size="xs" variant="light" leftSection={<IconFile size={14} />}>
        Browse
      </Button>
    )}
  </FileButton>
  {file.file_path && (
    <>
      <Text size="xs" truncate style={{ flex: 1 }} title={file.file_path}>
        {file.file_path.split('\\').pop() || file.file_path}
      </Text>
      <ActionIcon
        size="xs"
        variant="subtle"
        color="gray"
        onClick={() => handleUpdateFilePath(index, '')}
      >
        <IconX size={14} />
      </ActionIcon>
    </>
  )}
</Group>
```

### Example 2: Backend File Browse Endpoint (Alternative)

**New file: routes.py addition**
```python
# Source: Python tkinter docs + FastAPI patterns
import asyncio
from tkinter import Tk, filedialog

def _open_file_dialog():
    """Open native file dialog - runs in separate thread"""
    root = Tk()
    root.withdraw()
    root.attributes('-topmost', True)
    root.focus_force()

    file_path = filedialog.askopenfilename(
        title="Select Mathcad Prime file",
        filetypes=[
            ("Mathcad Prime", "*.mcdx"),
            ("All files", "*.*")
        ],
        initialdir="C:\\"  # Or last used directory
    )

    root.destroy()
    return file_path

@router.post("/files/browse")
async def browse_for_file():
    """
    Open native Windows file dialog and return selected path.
    This endpoint blocks until user selects file or cancels.
    """
    try:
        file_path = await asyncio.to_thread(_open_file_dialog)
        if not file_path:
            return {"file_path": None, "cancelled": True}
        return {"file_path": file_path, "cancelled": False}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"File dialog error: {str(e)}")
```

### Example 3: FileButton with Reset and Validation

```typescript
// Source: https://mantine.dev/core/file-button/
import { useState, useRef } from 'react';
import { FileButton, Button, Text, Group, Alert } from '@mantine/core';
import { IconUpload } from '@tabler/icons-react';

function MathcadFilePicker({ onFileSelect }: { onFileSelect: (path: string) => void }) {
  const [file, setFile] = useState<File | null>(null);
  const [error, setError] = useState<string | null>(null);
  const resetRef = useRef<() => void>(null);

  const handleChange = (selectedFile: File | null) => {
    if (!selectedFile) {
      setError(null);
      setFile(null);
      return;
    }

    // Validate file extension
    if (!selectedFile.name.toLowerCase().endsWith('.mcdx')) {
      setError('Please select a .mcdx file');
      setFile(null);
      resetRef.current?.();
      return;
    }

    setError(null);
    setFile(selectedFile);

    // Extract path and notify parent
    const fullPath = (selectedFile as any).path || selectedFile.name;
    onFileSelect(fullPath);
  };

  const handleClear = () => {
    setFile(null);
    setError(null);
    resetRef.current?.();
    onFileSelect('');
  };

  return (
    <div>
      <Group>
        <FileButton
          resetRef={resetRef}
          onChange={handleChange}
          accept=".mcdx,.MCDX"
        >
          {(props) => (
            <Button
              {...props}
              leftSection={<IconUpload size={16} />}
            >
              Select Mathcad File
            </Button>
          )}
        </FileButton>

        {file && (
          <>
            <Text size="sm">{file.name}</Text>
            <Button variant="subtle" size="xs" onClick={handleClear}>
              Clear
            </Button>
          </>
        )}
      </Group>

      {error && (
        <Alert color="red" mt="xs">
          {error}
        </Alert>
      )}
    </div>
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `<input type="file">` only | File System Access API (showOpenFilePicker) | 2020-2021 | More control, but Chromium-only; not needed for simple use case |
| Manual file validation | accept attribute + programmatic validation | Always available | Better UX with OS-level filtering |
| Synchronous file dialogs | Async/Promise-based APIs | ES6+ era | Better for non-blocking UI |
| tkinter in main thread | asyncio.to_thread() | Python 3.9+ | Safer for web servers |

**Deprecated/outdated:**
- **Direct File.path access in browsers:** Never standardized, mostly removed for security. Use File object APIs instead or backend dialogs.
- **webkitdirectory without proper fallbacks:** Webkit-specific, use standard directory picker APIs or File System Access API where supported.

## Open Questions

Things that couldn't be fully resolved:

1. **Path extraction in PyWebview context**
   - What we know: PyInstaller packaging (Phase 5) may use PyWebview or similar for UI
   - What's unclear: Exact method to extract full file paths from File objects in that environment
   - Recommendation: Test with PyWebview during Phase 5; if paths not accessible, implement backend dialog approach (Pattern 3)

2. **User preference for file dialog starting directory**
   - What we know: tkinter supports initialdir parameter
   - What's unclear: Whether to persist last-used directory between sessions
   - Recommendation: Start with user's home directory or C:\, add persistence in Phase 4 (Library & Persistence) if users request it

3. **Drag-and-drop support**
   - What we know: Mantine has a separate Dropzone component for drag-and-drop
   - What's unclear: Whether users would benefit from drag-and-drop in addition to browse button
   - Recommendation: Browse button is sufficient for Phase 3.1; consider drag-and-drop as future enhancement if users request it

## Sources

### Primary (HIGH confidence)
- [Mantine FileButton documentation](https://mantine.dev/core/file-button/) - Official docs for FileButton component
- [Mantine FileInput documentation](https://mantine.dev/core/file-input/) - Official docs for FileInput component (currently used for CSV)
- [MDN Window.showOpenFilePicker()](https://developer.mozilla.org/en-US/docs/Web/API/Window/showOpenFilePicker) - Modern File System Access API
- [Python Tkinter File Dialog Tutorial](https://www.pythontutorial.net/tkinter/tkinter-open-file-dialog/) - Official tkinter file dialog documentation
- [Python tkinter.filedialog docs](https://docs.python.org/3/library/dialog.html) - Official Python 3.14 documentation

### Secondary (MEDIUM confidence)
- [File Upload UX Best Practices](https://uploadcare.com/blog/file-uploader-ux-best-practices/) - UX patterns for file selection
- [Electron vs. Tauri comparison](https://www.dolthub.com/blog/2025-11-13-electron-vs-tauri/) - Desktop app framework comparison
- [FastAPI + tkinter integration example](https://github.com/henrikac/fastapi-docker-tkinter) - Proof of concept
- [File System Access API overview](https://wicg.github.io/file-system-access/) - W3C specification
- [PyInstaller documentation](https://pyinstaller.org/en/stable/usage.html) - Official PyInstaller usage guide

### Tertiary (LOW confidence)
- [Browser file path security](https://copyprogramming.com/howto/get-full-path-from-input-type-file-javascript) - Explains path restrictions
- [tkinter thread safety issues](https://bugs.python.org/issue11077) - Known Python bug tracker issue
- Various web search results about file picker implementations - Need validation in specific context

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Mantine FileButton is well-documented and already in use for CSV uploads
- Architecture: MEDIUM-HIGH - Browser approach is proven, but path extraction in desktop context needs Phase 5 validation
- Pitfalls: HIGH - Thread safety and browser security restrictions are well-documented issues

**Research date:** 2026-01-26
**Valid until:** 60 days (stable browser APIs and mature libraries; no fast-moving changes expected)
