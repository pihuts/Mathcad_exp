---
phase: 03-workflow-orchestration
plan: 07
type: execute
wave: 1
depends_on: [03-04]
files_modified:
  - frontend/src/hooks/useWorkflow.ts
autonomous: true

must_haves:
  truths:
    - Hook provides createWorkflow function
    - Hook provides getWorkflowStatus function
    - Hook provides stopWorkflow function
    - Hook manages workflow state (activeWorkflowId, status, error)
    - Hook polls workflow status during execution (using TanStack Query)
  artifacts:
    - path: frontend/src/hooks/useWorkflow.ts
      provides: Workflow state management
      min_lines: 80
  key_links:
    - from: useWorkflow
      to: createWorkflow API
      via: api.ts integration
      pattern: createWorkflow\(config\)
---

<objective>
Create useWorkflow custom hook for workflow creation, execution, and status monitoring.

Purpose: Centralize workflow state management and API calls, following useBatch pattern for consistency.

Output: useWorkflow hook with create, status polling, and stop functionality
</object>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@frontend/src/services/api.ts
@frontend/src/hooks/useBatch.ts
</context>

<tasks>

<task type="auto">
  <name>Create useWorkflow hook</name>
  <files>frontend/src/hooks/useWorkflow.ts</files>
  <action>
    Create frontend/src/hooks/useWorkflow.ts:

    ```typescript
    import { useState } from 'react';
    import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
    import {
      createWorkflow,
      getWorkflowStatus,
      stopWorkflow,
      WorkflowConfig,
      WorkflowStatusResponse,
      WorkflowStatus,
    } from '../services/api';

    export const useWorkflow = () => {
      const queryClient = useQueryClient();
      const [activeWorkflowId, setActiveWorkflowId] = useState<string | null>(null);
      const [error, setError] = useState<string | null>(null);

      // Poll workflow status
      const { data: workflowData, isLoading } = useQuery({
        queryKey: ['workflow', activeWorkflowId],
        queryFn: () => getWorkflowStatus(activeWorkflowId!),
        enabled: !!activeWorkflowId && (
          !workflowData?.status ||
          workflowData.status === WorkflowStatus.PENDING ||
          workflowData.status === WorkflowStatus.RUNNING
        ),
        refetchInterval: 1000, // Poll every second
        retry: false,
      });

      // Create workflow mutation
      const createMutation = useMutation({
        mutationFn: (config: WorkflowConfig) => createWorkflow(config),
        onSuccess: (data) => {
          setActiveWorkflowId(data.workflow_id);
          setError(null);
        },
        onError: (err: any) => {
          setError(err.message || 'Failed to create workflow');
        },
      });

      // Stop workflow mutation
      const stopMutation = useMutation({
        mutationFn: () => stopWorkflow(activeWorkflowId!),
        onSuccess: () => {
          queryClient.invalidateQueries({ queryKey: ['workflow', activeWorkflowId] });
        },
        onError: (err: any) => {
          setError(err.message || 'Failed to stop workflow');
        },
      });

      const createWorkflowHandler = (config: WorkflowConfig) => {
        createMutation.mutate(config);
      };

      const stopWorkflowHandler = () => {
        if (activeWorkflowId) {
          stopMutation.mutate();
        }
      };

      // Auto-reset active workflow when completed/failed/stopped
      if (workflowData?.status === WorkflowStatus.COMPLETED ||
          workflowData?.status === WorkflowStatus.FAILED ||
          workflowData?.status === WorkflowStatus.STOPPED) {
        // Keep activeWorkflowId for result viewing, don't auto-reset
      }

      return {
        createWorkflow: createWorkflowHandler,
        stopWorkflow: stopWorkflowHandler,
        workflowData,
        activeWorkflowId,
        isLoading,
        error,
        isCreating: createMutation.isPending,
        isStopping: stopMutation.isPending,
      };
    };
    ```
  </action>
  <verify>
    Verify:
    - useWorkflow.ts exists
    - Hook returns createWorkflow, stopWorkflow functions
    - Hook manages activeWorkflowId, workflowData, error state
    - TanStack Query is used for status polling
    - Polling stops when workflow completes/fails/stops
  </verify>
  <done>
    useWorkflow hook created with TanStack Query integration
  </done>
</task>

</tasks>

<verification>
Check hook compiles and follows useBatch patterns for consistency.
</verification>

<success_criteria>
- useWorkflow hook compiles without TypeScript errors
- Hook exports all required functions and state
- TanStack Query polling is configured correctly
- Error handling is consistent with useBatch
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-orchestration/03-07-SUMMARY.md`
</output>
