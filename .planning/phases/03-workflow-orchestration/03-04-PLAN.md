---
phase: 03-workflow-orchestration
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/services/api.ts
autonomous: true

must_haves:
  truths:
    - Workflow types mirror backend Pydantic models
    - WorkflowConfig, WorkflowFile, FileMapping are defined
    - WorkflowStatus enum matches backend values
    - WorkflowStatusResponse matches API return shape
  artifacts:
    - path: frontend/src/services/api.ts
      provides: Workflow TypeScript types
      contains:
        - interface FileMapping
        - interface WorkflowFile
        - interface WorkflowConfig
        - enum WorkflowStatus
        - interface WorkflowStatusResponse
  key_links:
    - from: frontend types
      to: backend models
      via: Type synchronization
      pattern: field names match protocol.py models
---

<objective>
Add TypeScript interfaces for workflow types to match backend Pydantic models.

Purpose: Type safety across frontend-backend boundary prevents runtime errors and enables IDE autocomplete for workflow configuration.

Output: Workflow-related TypeScript types in api.ts
</object>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@frontend/src/services/api.ts
@src/engine/protocol.py
</context>

<tasks>

<task type="auto">
  <name>Add workflow TypeScript types to api.ts</name>
  <files>frontend/src/services/api.ts</files>
  <action>
    Add the following workflow types to frontend/src/services/api.ts after MetaData interface:

    ```typescript
    export interface FileMapping {
      source_file: string;
      source_alias: string;
      target_file: string;
      target_alias: string;
    }

    export interface WorkflowFile {
      file_path: string;
      inputs: InputConfig[];
      position: number;
    }

    export interface WorkflowConfig {
      name: string;
      files: WorkflowFile[];
      mappings: FileMapping[];
      stop_on_error: boolean;
    }

    export enum WorkflowStatus {
      PENDING = "pending",
      RUNNING = "running",
      COMPLETED = "completed",
      FAILED = "failed",
      STOPPED = "stopped",
    }

    export interface WorkflowStatusResponse {
      workflow_id: string;
      status: string;
      current_file_index: number;
      total_files: number;
      completed_files: string[];
      progress: number;
      error?: string;
    }

    export interface WorkflowCreateResponse {
      workflow_id: string;
      status: string;
    }
    ```

    Then add API functions after existing getInputs function:

    ```typescript
    export const createWorkflow = async (config: WorkflowConfig): Promise<WorkflowCreateResponse> => {
      const { data } = await api.post<WorkflowCreateResponse>('/workflows', config);
      return data;
    };

    export const getWorkflowStatus = async (workflowId: string): Promise<WorkflowStatusResponse> => {
      const { data } = await api.get<WorkflowStatusResponse>(`/workflows/${workflowId}`);
      return data;
    };

    export const stopWorkflow = async (workflowId: string): Promise<ControlResponse> => {
      const { data } = await api.post<ControlResponse>(`/workflows/${workflowId}/stop`);
      return data;
    };
    ```
  </action>
  <verify>
    Verify:
    - FileMapping interface exists with source_file, source_alias, target_file, target_alias
    - WorkflowFile interface exists with file_path, inputs, position
    - WorkflowConfig interface exists with name, files, mappings, stop_on_error
    - WorkflowStatus enum exists with all 5 values
    - API functions createWorkflow, getWorkflowStatus, stopWorkflow are defined
  </verify>
  <done>
    Workflow TypeScript types and API functions added to api.ts
  </done>
</task>

</tasks>

<verification>
Check that TypeScript types compile and match backend model structure.
</verification>

<success_criteria>
- All workflow types compile without TypeScript errors
- Type fields match backend Pydantic models exactly
- API functions use correct endpoint paths
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-orchestration/03-04-SUMMARY.md`
</output>
