---
phase: 03-workflow-orchestration
plan: 08
type: execute
wave: 1
depends_on: [03-05, 03-06, 03-07]
files_modified:
  - frontend/src/App.tsx
autonomous: false

must_haves:
  truths:
    - User can navigate between Batch and Workflow tabs
    - User can add files, configure inputs, and create mappings
    - User can start workflow and view progress
    - User can stop workflow execution
    - Workflow results display completed files and outputs
  artifacts:
    - path: frontend/src/App.tsx
      provides: Workflow UI integration
      min_lines: 50 (new code added)
  key_links:
    - from: App.tsx
      to: WorkflowBuilder
      via: Component integration
      pattern: <WorkflowBuilder
    - from: App.tsx
      to: useWorkflow
      via: Hook integration
      pattern: useWorkflow\(\)
---

<objective>
Integrate WorkflowBuilder, MappingModal, and useWorkflow into App.tsx with tab navigation.

Purpose: Provide complete workflow UI integrated with existing batch functionality, allowing users to switch between batch and workflow modes.

Output: App.tsx updated with Workflow tab and full workflow functionality
</object>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@frontend/src/App.tsx
@frontend/src/components/WorkflowBuilder.tsx
@frontend/src/components/MappingModal.tsx
@frontend/src/hooks/useWorkflow.ts
@frontend/src/components/InputModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Integrate workflow UI into App.tsx</name>
  <files>frontend/src/App.tsx</files>
  <action>
    Update frontend/src/App.tsx to add workflow functionality:

    1. Add imports at top:
    ```typescript
    import { Tabs } from '@mantine/core';
    import { WorkflowBuilder } from './components/WorkflowBuilder';
    import { MappingModal } from './components/MappingModal';
    import { useWorkflow } from './hooks/useWorkflow';
    import { WorkflowFile, FileMapping, MetaData, WorkflowConfig, WorkflowStatus } from './services/api';
    ```

    2. Add workflow state in App component (after existing state):
    ```typescript
    const [activeTab, setActiveTab] = useState<string | null>('batch');
    const [workflowFiles, setWorkflowFiles] = useState<WorkflowFile[]>([]);
    const [workflowMappings, setWorkflowMappings] = useState<FileMapping[]>([]);
    const [mappingModalFile, setMappingModalFile] = useState<WorkflowFile | null>(null);
    const [workflowInputFile, setWorkflowInputFile] = useState<WorkflowFile | null>(null);
    const [filesMetadata, setFilesMetadata] = useState<Record<string, MetaData>>({});
    ```

    3. Add workflow hook call:
    ```typescript
    const {
      createWorkflow,
      stopWorkflow,
      workflowData,
      activeWorkflowId,
      isLoading: workflowLoading,
      error: workflowError,
      isCreating,
      isStopping,
    } = useWorkflow();
    ```

    4. Add workflow handler functions:
    ```typescript
    const handleOpenMappingModal = (file: WorkflowFile) => {
      setMappingModalFile(file);
    };

    const handleSaveMappings = (mappings: FileMapping[]) => {
      if (mappingModalFile) {
        // Remove old mappings for this file and add new ones
        const otherMappings = workflowMappings.filter(
          (m) => m.target_file !== mappingModalFile.file_path
        );
        setWorkflowMappings([...otherMappings, ...mappings]);
      }
      setMappingModalFile(null);
    };

    const handleConfigureWorkflowInputs = async (file: WorkflowFile) => {
      if (!file.file_path) return;

      try {
        const meta = await getInputs(file.file_path);
        setFilesMetadata(prev => ({
          ...prev,
          [file.file_path]: meta,
        }));
        setWorkflowInputFile(file);
      } catch (err: any) {
        console.error("Failed to analyze file", err);
      }
    };

    const handleSaveWorkflowInputs = (alias: string, config: any) => {
      // Handle InputConfig object {alias, value, units} from InputModal
      const values = Array.isArray(config) ? config : config.value;
      const units = Array.isArray(config) ? undefined : config.units;

      if (workflowInputFile) {
        const newFiles = [...workflowFiles];
        const fileIndex = newFiles.findIndex(f => f.file_path === workflowInputFile.file_path);

        if (fileIndex >= 0) {
          // Create InputConfig for the alias
          const inputConfig: InputConfig = {
            alias,
            value: Array.isArray(values) ? values[0] : values,
            units,
          };

          // Replace or add input config for this alias
          const existingIndex = newFiles[fileIndex].inputs.findIndex(i => i.alias === alias);
          if (existingIndex >= 0) {
            newFiles[fileIndex].inputs[existingIndex] = inputConfig;
          } else {
            newFiles[fileIndex].inputs.push(inputConfig);
          }

          setWorkflowFiles(newFiles);
        }
      }

      setWorkflowInputFile(null);
    };

    const handleRunWorkflow = () => {
      if (workflowFiles.length === 0) return;

      const workflowConfig: WorkflowConfig = {
        name: `workflow-${Date.now()}`,
        files: workflowFiles,
        mappings: workflowMappings,
        stop_on_error: true,
      };

      createWorkflow(workflowConfig);
    };

    const workflowProgress = workflowData ? workflowData.progress : 0;
    ```

    5. Wrap existing AppShell content in Tabs:
    ```typescript
    <AppShell.Main>
      <Container size="xl">
        <Tabs value={activeTab} onChange={setActiveTab}>
          <Tabs.List>
            <Tabs.Tab value="batch">Batch Processing</Tabs.Tab>
            <Tabs.Tab value="workflow">Workflow Orchestration</Tabs.Tab>
          </Tabs.List>

          <Tabs.Panel value="batch">
            {/* Existing batch processing content */}
            { /* ... existing batch code ... */ }
          </Tabs.Panel>

          <Tabs.Panel value="workflow">
            <Stack gap="xl">
              <Title order={3}>Workflow Orchestration</Title>
              <Text size="sm" c="dimmed">
                Chain multiple Mathcad files where outputs drive downstream inputs. Files execute in order (top to bottom).
              </Text>

              {workflowError && (
                <Alert icon={<IconAlertCircle size={16} />} title="Error" color="red" withCloseButton onClose={() => setError(null)}>
                  {workflowError}
                </Alert>
              )}

              <WorkflowBuilder
                files={workflowFiles}
                mappings={workflowMappings}
                onFilesChange={setWorkflowFiles}
                onMappingsChange={setWorkflowMappings}
                onOpenMappingModal={handleOpenMappingModal}
                onConfigureInputs={handleConfigureWorkflowInputs}
              />

              <Group justify="flex-end">
                <Button
                  disabled={workflowFiles.length === 0 || workflowFiles.some(f => !f.file_path)}
                  onClick={handleRunWorkflow}
                  loading={isCreating || (activeWorkflowId && workflowLoading)}
                >
                  Run Workflow
                </Button>
              </Group>

              {activeWorkflowId && (
                <Stack gap="xs">
                  <Group justify="space-between">
                    <Title order={4}>Workflow Progress</Title>
                    <Group>
                      <Text size="sm">
                        Status: {workflowData?.status?.toUpperCase() || 'RUNNING'}
                      </Text>
                      {workflowData?.status === WorkflowStatus.RUNNING && (
                        <Button color="red" variant="light" size="xs" onClick={stopWorkflow} loading={isStopping}>
                          Stop Workflow
                        </Button>
                      )}
                    </Group>
                  </Group>
                  <Progress value={workflowProgress} animated={workflowData?.status === WorkflowStatus.RUNNING} />

                  {workflowData && (
                    <Stack gap="xs" mt="md">
                      <Group>
                        <Text size="sm">Current File: {workflowData.current_file_index + 1} / {workflowData.total_files}</Text>
                        <Text size="sm">Completed: {workflowData.completed_files.length}</Text>
                      </Group>

                      {workflowData.completed_files.length > 0 && (
                        <Paper p="md" withBorder>
                          <Text fw={500} mb="xs">Completed Files:</Text>
                          <Stack gap="xs">
                            {workflowData.completed_files.map((file, idx) => (
                              <Text key={idx} size="sm">{idx + 1}. {file}</Text>
                            ))}
                          </Stack>
                        </Paper>
                      )}

                      {workflowData.status === WorkflowStatus.FAILED && workflowData.error && (
                        <Alert color="red">
                          <Text size="sm">Error: {workflowData.error}</Text>
                        </Alert>
                      )}
                    </Stack>
                  )}
                </Stack>
              )}
            </Stack>
          </Tabs.Panel>
        </Tabs>
      </Container>
    </AppShell.Main>
    ```

    6. Add MappingModal at end (after InputModal):
    ```typescript
    <MappingModal
      opened={!!mappingModalFile}
      onClose={() => setMappingModalFile(null)}
      targetFile={mappingModalFile || { file_path: '', inputs: [], position: 0 }}
      allFiles={workflowFiles}
      filesMetadata={filesMetadata}
      currentMappings={workflowMappings.filter(m => m.target_file === mappingModalFile?.file_path)}
      onSave={handleSaveMappings}
    />
    ```

    7. Reuse InputModal for workflow inputs by adding:
    ```typescript
    <InputModal
      opened={!!workflowInputFile}
      onClose={() => setWorkflowInputFile(null)}
      alias={workflowInputFile?.inputs[0]?.alias || ''}
      onSave={(values) => handleSaveWorkflowInputs(workflowInputFile?.inputs[0]?.alias || '', values)}
    />
    ```

    Note: This is a simplified version. Full implementation should handle multiple inputs per file, better file picker, and enhanced metadata caching.
  </action>
  <verify>
    Verify:
    - Tabs added to App.tsx for batch/workflow switching
    - WorkflowBuilder component integrated
    - MappingModal component integrated
    - useWorkflow hook integrated
    - Workflow state managed correctly
    - Progress display shows current file and completed files
  </verify>
  <done>
    Workflow UI integrated into App.tsx with tab navigation
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete workflow UI with WorkflowBuilder, MappingModal, and workflow execution</what-built>
  <how-to-verify>
    1. Start frontend (npm run dev) and backend (python main.py)
    2. Open browser and navigate to Workflow tab
    3. Add 2-3 Mathcad files to workflow (use file paths from existing batch tests)
    4. Configure inputs for each file by clicking settings icon
    5. Add mappings by clicking green + icon on downstream files
    6. Click "Run Workflow"
    7. Verify progress bar updates
    8. Verify completed files list shows progress
    9. Test stop button during execution
    10. Switch back to Batch tab to verify existing functionality still works
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
Check that UI compiles, tabs work, and workflow can be created and executed.
</verification>

<success_criteria>
- App.tsx compiles without TypeScript errors
- Tabs switch between batch and workflow modes
- WorkflowBuilder renders and file operations work
- MappingModal opens and saves mappings
- Workflow executes and progress displays correctly
- Stop button halts workflow execution
- Batch functionality remains functional
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-orchestration/03-08-SUMMARY.md`
</output>
