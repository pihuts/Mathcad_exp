---
phase: 03-workflow-orchestration
plan: 02
type: execute
wave: 1
depends_on: [03-01]
files_modified:
  - src/engine/workflow_manager.py
autonomous: true

must_haves:
  truths:
    - WorkflowManager executes files in linear order (0, 1, 2...)
    - WorkflowManager passes outputs from File A to inputs of File B
    - WorkflowManager stores intermediate results for mapping
    - WorkflowManager supports stop_on_error flag
    - WorkflowManager runs in background thread
  artifacts:
    - path: src/engine/workflow_manager.py
      provides: Workflow orchestration logic
      exports:
        - class WorkflowManager
      min_lines: 100
  key_links:
    - from: WorkflowManager
      to: EngineManager
      via: submit_job for file calculations
      pattern: self\.engine\.submit_job
    - from: WorkflowManager
      to: BatchManager
      via: Polling pattern for job completion
      pattern: _poll_result
---

<objective>
Create WorkflowManager class to orchestrate multi-file workflows with linear execution and output-to-input mapping.

Purpose: WorkflowManager is the core engine for Phase 3 - it coordinates execution of multiple Mathcad files in sequence, passing calculated outputs to downstream inputs.

Output: WorkflowManager class with submit_workflow, get_status, stop_workflow methods
</object>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-workflow-orchestration/03-01-SUMMARY.md
@src/engine/protocol.py
@src/engine/batch_manager.py
@src/engine/manager.py
</context>

<tasks>

<task type="auto">
  <name>Create WorkflowManager class</name>
  <files>src/engine/workflow_manager.py</files>
  <action>
    Create src/engine/workflow_manager.py with the WorkflowManager class:

    ```python
    import threading
    import time
    from typing import List, Dict, Any, Optional
    from engine.manager import EngineManager
    from engine.protocol import (
        WorkflowConfig, WorkflowState, WorkflowStatus,
        InputConfig, FileMapping
    )

    class WorkflowManager:
        def __init__(self, engine_manager: EngineManager):
            self.engine = engine_manager
            self.workflows: Dict[str, WorkflowState] = {}

        def submit_workflow(self, workflow_id: str, config: WorkflowConfig) -> str:
            """Submit a workflow for execution in background thread"""
            state = WorkflowState(workflow_id=workflow_id, config=config)
            self.workflows[workflow_id] = state

            thread = threading.Thread(
                target=self._execute_workflow,
                args=(workflow_id,),
                daemon=True
            )
            thread.start()
            return workflow_id

        def _execute_workflow(self, workflow_id: str):
            """Execute workflow in linear order (0, 1, 2...)"""
            state = self.workflows[workflow_id]
            state.status = WorkflowStatus.RUNNING
            intermediate_results = {}  # {file_path: {alias: value}}

            for file_config in state.config.files:
                try:
                    # Build inputs for this file (explicit + mapped)
                    inputs = self._resolve_inputs(file_config, intermediate_results, state.config.mappings)

                    # Execute calculation
                    job_id = self.engine.submit_job("calculate_job", {
                        "path": file_config.file_path,
                        "inputs": inputs
                    })

                    result = self._poll_result(job_id)
                    if result and result.status == "success":
                        # Store outputs for downstream mapping
                        intermediate_results[file_config.file_path] = result.data
                        state.completed_files.append(file_config.file_path)
                    else:
                        raise Exception(result.error_message if result else "Job timeout")

                    state.current_file_index += 1

                except Exception as e:
                    state.status = WorkflowStatus.FAILED
                    state.error = str(e)
                    if state.config.stop_on_error:
                        break

            if state.status != WorkflowStatus.FAILED:
                state.status = WorkflowStatus.COMPLETED
                state.final_results = intermediate_results

        def _resolve_inputs(self, file_config, intermediate_results, mappings) -> List[InputConfig]:
            """Build InputConfigs combining explicit inputs and mapped outputs"""
            inputs = []

            # Start with explicit user inputs
            for input_config in file_config.inputs:
                inputs.append(input_config)

            # Add mapped outputs from upstream files
            relevant_mappings = [m for m in mappings if m.target_file == file_config.file_path]
            for mapping in relevant_mappings:
                source_data = intermediate_results.get(mapping.source_file, {})
                if mapping.source_alias in source_data:
                    inputs.append(InputConfig(
                        alias=mapping.target_alias,
                        value=source_data[mapping.source_alias]
                    ))

            return inputs

        def _poll_result(self, job_id: str, timeout: float = 30.0) -> Optional[Any]:
            """Poll EngineManager for job completion (reuse BatchManager pattern)"""
            start = time.time()
            while time.time() - start < timeout:
                res = self.engine.get_job(job_id)
                if res:
                    return res
                time.sleep(0.5)
            return None

        def get_status(self, workflow_id: str) -> Optional[Dict[str, Any]]:
            """Get current workflow status"""
            state = self.workflows.get(workflow_id)
            if not state:
                return None

            return {
                "workflow_id": state.workflow_id,
                "status": state.status.value,
                "current_file_index": state.current_file_index,
                "total_files": len(state.config.files),
                "completed_files": state.completed_files,
                "progress": int((state.current_file_index / len(state.config.files)) * 100) if state.config.files else 0,
                "error": state.error
            }

        def stop_workflow(self, workflow_id: str):
            """Stop a running workflow"""
            state = self.workflows.get(workflow_id)
            if state and state.status == WorkflowStatus.RUNNING:
                state.status = WorkflowStatus.STOPPED
    ```

    Then update src/engine/manager.py to initialize WorkflowManager:
    - Add import at top: `from engine.workflow_manager import WorkflowManager`
    - In __init__, after BatchManager init: `self.workflow_manager = WorkflowManager(self)`
  </action>
  <verify>
    Verify:
    - src/engine/workflow_manager.py exists with WorkflowManager class
    - src/engine/manager.py imports and initializes WorkflowManager
    - WorkflowManager has submit_workflow, get_status, stop_workflow methods
    - Execution is in background thread (threading.Thread)
  </verify>
  <done>
    WorkflowManager class created and integrated with EngineManager
  </done>
</task>

</tasks>

<verification>
Check that WorkflowManager follows BatchManager patterns (threading, polling, status tracking).
</verification>

<success_criteria>
- WorkflowManager compiles without errors
- EngineManager initializes WorkflowManager on startup
- Workflow execution follows linear chain pattern
- Output-to-input mapping resolves correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-orchestration/03-02-SUMMARY.md`
</output>
