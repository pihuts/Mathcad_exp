---
phase: 03-workflow-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/engine/protocol.py
autonomous: true

must_haves:
  truths:
    - Workflow models use Pydantic for type safety
    - Models support linear chain configuration (A → B → C)
    - Models support explicit Output-to-Input mapping
    - Models allow stop_on_error configuration
  artifacts:
    - path: src/engine/protocol.py
      provides: Workflow data models
      contains:
        - class FileMapping
        - class WorkflowFile
        - class WorkflowConfig
        - class WorkflowStatus
        - class WorkflowState
  key_links:
    - from: WorkflowFile
      to: InputConfig
      via: Reuse existing InputConfig type
      pattern: inputs.*List\[InputConfig\]
---

<objective>
Add Pydantic models for workflow configuration to support multi-file chaining with explicit mappings.

Purpose: Type-safe data structures are foundational for workflow orchestration. Models enable serialization, validation, and clear API contracts between frontend and backend.

Output: WorkflowFile, FileMapping, WorkflowConfig, WorkflowStatus, WorkflowState models in protocol.py
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/engine/protocol.py
</context>

<tasks>

<task type="auto">
  <name>Add workflow Pydantic models to protocol.py</name>
  <files>src/engine/protocol.py</files>
  <action>
    Add the following models to src/engine/protocol.py after the InputConfig dataclass:

    ```python
    from enum import Enum
    from pydantic import BaseModel, Field, validator

    class FileMapping(BaseModel):
        """Maps an output from one file to an input in another"""
        source_file: str  # e.g., "file_a.mcdx"
        source_alias: str  # e.g., "Stress_Result"
        target_file: str  # e.g., "file_b.mcdx"
        target_alias: str  # e.g., "Input_Stress"

    class WorkflowFile(BaseModel):
        """Single file in workflow chain"""
        file_path: str
        inputs: List[InputConfig]  # Reuse existing InputConfig
        position: int = Field(default=0, ge=0)  # 0, 1, 2 for linear chain A->B->C

    class WorkflowConfig(BaseModel):
        """Complete workflow configuration"""
        name: str = Field(..., min_length=1, max_length=100)
        files: List[WorkflowFile]
        mappings: List[FileMapping]  # Links files together
        stop_on_error: bool = True  # Stop entire chain on failure
  ```

    Then add WorkflowStatus and WorkflowState dataclasses for runtime tracking:

    ```python
    from dataclasses import dataclass, field
    from typing import Dict, List, Optional

    class WorkflowStatus(str, Enum):
        PENDING = "pending"
        RUNNING = "running"
        COMPLETED = "completed"
        FAILED = "failed"
        STOPPED = "stopped"

    @dataclass
    class WorkflowState:
        workflow_id: str
        config: WorkflowConfig
        status: WorkflowStatus = WorkflowStatus.PENDING
        current_file_index: int = 0
        completed_files: List[str] = field(default_factory=list)
        intermediate_results: Dict[str, Dict[str, Any]] = field(default_factory=dict)
        error: Optional[str] = None
        final_results: Optional[Dict[str, Any]] = None
    ```
  </action>
  <verify>
    Read src/engine/protocol.py and verify:
    - FileMapping class exists with source_file, source_alias, target_file, target_alias fields
    - WorkflowFile class exists with file_path, inputs, position fields
    - WorkflowConfig class exists with name, files, mappings, stop_on_error fields
    - WorkflowStatus enum exists with PENDING, RUNNING, COMPLETED, FAILED, STOPPED values
    - WorkflowState dataclass exists with all required fields
  </verify>
  <done>
    Workflow models defined in protocol.py with proper Pydantic validation
  </done>
</task>

</tasks>

<verification>
Check that models compile without errors and follow Pydantic patterns.
</verification>

<success_criteria>
- All workflow models compile and have correct field types
- InputConfig is properly imported and used in WorkflowFile
- Models support the requirements (linear chain, explicit mapping, stop_on_error)
</success_criteria>

<output>
After completion, create `.planning/phases/03-workflow-orchestration/03-01-SUMMARY.md`
</output>
